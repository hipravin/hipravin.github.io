---
layout: post
title: Работа в IntelliJ IDEA
excerpt: Возможности, которые я использую регулярно, основные сочетания клавиш, а также полезные мелочи.
---

<p xmlns:xs="http://www.w3.org/2001/XMLSchema">
    В <a href="/2020-03-10-idea-debug/">одном из прошлых постов</a> я рассказывал о возможностях отладки Java кода в IDEA.
    Сегодня перечислю комбинации клавиш и тот функционал, который я использую регулярно.
    Ничего сверхъестественного, хитрого, заумного и неочевидного не будет. Пожалуй, даже отдельного примера с кодом для этого поста делать не буду.
    Однако IDEA непрерывно развивается и приятные мелочи появляются с каждым релизом и заслуживают упоминания.
    Я даже специально не отключаю подсказки на старте приложения и периодически открываю для себя что-то новое.
</p>

<p>
    Начну с самых интересных возможностей, которые можно считать полноценными плагинами, а не просто удобствами редактора.
</p>

<h4>Генерация xsd по xml</h4>

<p>
    JAXB - по моему мнению наиболее удобный и универсальный способ работы с XML в Java.
    Подробно описывать его сейчас я не буду, да и получилось бы практически ровно то же, что уже есть на отличном <a href="https://www.baeldung.com/jaxb"> сайте Baeldung</a>.
    JAXB требует от разработчика указать набор классов с аннотациями, а работу по операциям marshall / unmarshall библиотека берет на себя.
    Однако критически важным является абсолютная точность именования полей классов и значений параметров аннотаций.
    Ошибки приводят к тому, что часть данных при парсинге проигнорируется, будто бы пришли пустые значения.
    Чтобы избежать этих ошибок нужно минимизировать ручные операции, заменив их автогенерацией кода.
    Для этого классы JAXB создают не вручную, а с помощью maven плагина, входным параметром которого является xsd схема.
    В IDEA тоже есть такой функционал, но начиная с Java 9 он <a href = "https://intellij-support.jetbrains.com/hc/en-us/community/posts/115000763384-JAXB-XJC-plugin-not-working">
    не работает из-за исключения соответствующей утилиты из состава JDK</a> (по крайней мере, на момент публикации).
    В случае, если источник xml файлов не предоставил нам xsd схемы, можно составить её самостоятельно.
    Конечно, это потребует определённых предположений и допущений, но этого не избежать.
    Далее покажу как использовать для этого встроенный функционал IDEA.
</p>

<ul class="ul-nob">
    <li>
        1. Копируем пример xml файла в проект.
        {% highlight xml %}
        <?xml version="1.0" encoding="UTF-8"?>
        <subtitles>
            <subtitle id="1">
                <content>À la volonté du peuple</content>
                <timecode value="seconds">
                    <start>1</start>
                    <end>5</end>
                </timecode>
            </subtitle>
            <subtitle id="2">
                <content>Et à la santé du progrès</content>
                <timecode value="seconds">
                    <start>6</start>
                    <end>10</end>
                </timecode>
            </subtitle>
        </subtitles>
        {% endhighlight %}
        2. Далее правая кнопка мыши -> Generate XSD schema from XML file
    </li>
    <li>
        <img class="code-snapshot" src="/img/posts/idea-usage/xml-to-xsd-1.PNG"
             alt="картинки нет, но вы держитесь"/>
    </li>
    <li>
        Здесь стоит обратить внимание на параметр "Detect Enumeration Limit", из-за которого в схеме появятся типы enumeration из-за того,
        что в нашем xml файле слишком мало различных значений.
        {% highlight xml %}
        <!-- subs.xsd -->
        ...
        <xs:element name="content">
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="À la volonté du peuple"/>
                    <xs:enumeration value="Et à la santé du progrès"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:element>
        {% endhighlight %}
        Enumeration в xsd схеме зверь довольно редкий, поэтому этот параметр можно выставить в 0.
    </li>
    <li>
        3. Схема сгенерированная с параметром Detect Enumeration Limit, равным 0

        {% highlight xml %}
        <?xml version="1.0" encoding="UTF-8"?>
        <xs:schema attributeFormDefault="unqualified" elementFormDefault="qualified"
                   xmlns:xs="http://www.w3.org/2001/XMLSchema">
            <xs:element name="subtitles" type="subtitlesType"/>
            <xs:complexType name="timecodeType">
                <xs:sequence>
                    <xs:element type="xs:string" name="start"/>
                    <xs:element type="xs:string" name="end"/>
                </xs:sequence>
                <xs:attribute type="xs:string" name="value" use="optional"/>
            </xs:complexType>
            <xs:complexType name="subtitleType">
                <xs:sequence>
                    <xs:element type="xs:string" name="content"/>
                    <xs:element type="timecodeType" name="timecode"/>
                </xs:sequence>
                <xs:attribute type="xs:string" name="id" use="optional"/>
            </xs:complexType>
            <xs:complexType name="subtitlesType">
                <xs:sequence>
                    <xs:element type="subtitleType" name="subtitle" maxOccurs="unbounded" minOccurs="0"/>
                </xs:sequence>
            </xs:complexType>
        </xs:schema>
        {% endhighlight %}
        4. Обязательно проводим ревью полученной схемы. В нашем случае меняем типы данных для start, end и id на xs:integer,
            ведь по характеру данных мы знаем, что это числовые значения, и в классах JAXB нам бы не хотелось видеть полей наподобие "String start",
        чтобы потом осуществлять преобразования явно в коде приложения.
        {% highlight xml %}
        <xs:sequence>
            <xs:element type="xs:integer" name="start"/>
            <xs:element type="xs:integer" name="end"/>
        </xs:sequence>
        {% endhighlight %}
        5. В общем, схема готова, можно приступать к работе с JAXB. Мы минимизировали вероятность ошибок, вызванных опечатками или невнимательностью.
        Однако юнит тесты всё равно будут необходимы, потому что генерация схемы - не точная операция,
        а скорее обходной маневр (workaround) в условиях, когда поставщик данных не описал строго их формат.
    </li>
</ul>

<h4>Регулярные выражения</h4>
<p>
    Небольшая, но исключительно полезная функциональность в IDEA - редактор регулярных выражений без запуска кода.
    До его появления приходилось либо запускать тест после каждого изменения регулярного выражения, либо пользоваться evaluate expression в отладчике,
    что намного эффективней, но всё равно не совсем удобно.
    Теперь же, стоит Вам в коде упомянуть класс Pattern, как слева появится всплывающая подсказка с опцией "Check RegExp", при выборе которой откроется мини редактор с двумя полями:
    регулярным выражением и произвольной строкой, которую мы хотим проверить. Теперь мы можем очень быстро менять выражение и строку, пока не получим нужный результат.
    Это важно, потому что пока Вы не станете гуру регулярных выражений, Вам потребуется много мелких исправлений и попыток, чтобы получить желаемый результат.
    Не просто так существует шутка, что если Вы стали решать проблему с помощью регулярного выражения, то теперь у Вас две проблемы.
    Отдельным приятным бонусом идёт то, что в окне этого редактора специальны конструкции, такие как "\S" (непробельный символ) используются точно так, как они описаны в документации javadoc,
    в то время как в коде нужно экранировать все обратные слэши ещё одним обратным слэшем (или слэшом). В последнем примере получилось восемь подряд.
</p>
<p>
    <img class="code-snapshot" src="/img/posts/idea-usage/pattern.PNG"
         alt="картинки нет, но вы держитесь"/>
    <img class="code-snapshot" src="/img/posts/idea-usage/regexp1.PNG"
         alt="картинки нет, но вы держитесь"/>
    <img class="code-snapshot" src="/img/posts/idea-usage/regexp2.PNG"
         alt="картинки нет, но вы держитесь"/>
</p>

<p>
    Когда мне нужно написать сложное выражение, например чтобы разобрать строку из лога приложения, то с использованием этого помощника я могу скопировать строчку "снизу вверх" и
    поэтапно заменять части строки на паттерны регулярного выражения, следя за тем, чтобы выражение подходило (Matches).
    Нужно только сразу экранировать все специальные символы. Второй вариант - формировать выражение слева направо,
    постепенно добавляя новые конструкции к выражению и текст к проверяемой строке.
</p>

<p>
    <img class="code-snapshot" src="/img/posts/idea-usage/regexp3.PNG"
         alt="картинки нет, но вы держитесь"/>
</p>

<h4>Диаграмма зависимостей</h4>
<p>
    Комбинация клавиш <strong>Ctrl+Alt+Shift+U</strong> при открытом pom.xml файле показывает граф зависимостей. Очень часто использую его,
    чтобы найти как в проект попадают зависимости на библиотеки, которые я не ожидал. В окне работает поиск по Ctrl+F.
</p>

<p>
    <img class="code-snapshot code-snapshot85" src="/img/posts/maven/idea-dependencies.png"
         alt="картинки нет, но вы держитесь"/>
</p>

<h4>
    Диаграмма классов
</h4>
<p>
    Недавно была добавлена ещё и диаграмма классов по той же комбинации Ctrl+Alt+Shift+U. Трудно сказать, будет ли эта возможность часто использоваться, ведь всё-таки
    сложные иерархии наследования в приложениях используются довольно редко. Но как минимум при изучении определённых классов Java подобное наглядное представление не будет лишним.
</p>

<p>
    <img class="code-snapshot" src="/img/posts/idea-usage/diagram1.PNG"
         alt="картинки нет, но вы держитесь"/>
    <img class="code-snapshot" src="/img/posts/idea-usage/diagram2.PNG"
         alt="картинки нет, но вы держитесь"/>

</p>

<p>
    Теперь расскажу о самых частых и полезных комбинациях клавиш. Рекомендую распечатать шпаргалку, которая находится в IDEA в меню Help -> Keymap Reference.
    Выглядит она так:
</p>

<img class="code-snapshot" src="/img/posts/idea-usage/idea-keymap.PNG"
     alt="картинки нет, но вы держитесь"/>

<p>
    Эта шпаргалка содержит все встроенные хоткеи, и я не смогу добавить к ним ничего нового. Тем не менее, хочу пояснить какие из них я использую
    чаще и как они делают разработку удобнее и эффективнее.
</p>

<h4>Ctrl+ALt+Right,Ctrl+Alt+Left</h4>
<p>
    Переход вперед и назад между последними файлами и позициями в файле. Не представляю себе IDEA без этой штуки. Например, пишете основной код для работы с базой данных,
    тест и тестовый скрипт. Чтобы перемещаться между этими файлами иначе пришлось бы брать мышь и искать файл в верхней панели.
    А с этой комбинацией клавиш за пару секунд и несколько быстрых нажатий попадёте на нужный файл.
    И это лучше, чем просто навигация между файлами, это навигация между последними позициями в файлах.
    Осторожно! В некоторых драйверах видеокарт это сочетание клавиш вращает экран. К счастью, это несложно отключить.
</p>

<h4>Ctrl+Q</h4>
<p>
    Открывает окно с документацией, обычно это Javadoc класса или метода. Этой возможностью нужно пользоваться как можно чаще, а не пользоваться ей
    совсем очень плохо. Никто никогда не запомнит всех нюансов использования всех библиотек, а такой способ всегда покажет самую правильную информацию (golden source).
    Часто хочется просто найти ответ или решение на Stackoverflow, а не вчитываться и разбираться с javadoc, но нужно стараться постепенно переходить к чтению оригинальной документации,
    потому что решение с форума может оказаться неверным или устаревшим. Примерчик для наглядности:
</p>

<p>
    <img class="code-snapshot" src="/img/posts/idea-usage/javadoc.PNG"
         alt="картинки нет, но вы держитесь"/>

</p>

<h4>Создать тест</h4>
<p>
    Чтобы создать JUnit тест на класс нужно перевести курсор на имя класса в заголовке, нажать комбинацию Alt+Enter, а в выпадающем списке выбрать "Create Test".
    Намного быстрее и удобнее, чем искать директорию с тестами, создавать пакет, а потом копировать или перепечатывать имя класса. Тест не должен располагаться где попало и иметь случайное название
    с добавкой "Test". Мы располагаем класс теста в том же пакете, чтобы были доступны поля и методы с модификаторами доступа default и protected,
    а называем по имени проверяемого класса - для порядка.
</p>

<p>
    <img class="code-snapshot" src="/img/posts/idea-usage/create-test.PNG"
         alt="картинки нет, но вы держитесь"/>

</p>

<h4>Ctrl+P</h4>
<p>
    Часто используемая и достаточно очевидная возможность, показывает список сигнатур метода, а также подсвечивает те параметры, которые уже подходят по типу.
    Также, как и с javadoc документацией, следует использовать как можно чаще, чтобы всегда быть в курсе существования дополнительных неочевидных параметров.
    Например, кодировки или часового пояса. Почти всегда стоит выбирать тот вариант метода, который использует явное указание подобных аргументов.
    Или например, используя коллектор toMap, можно заметить параметр mergeFunction, который намекает на то, что нам следует сперва понять,
    возможны ли в коллекции повторяющиеся элементы и как они обрабатываются без этого параметра.
</p>
<p>
    <img class="code-snapshot" src="/img/posts/idea-usage/params1.PNG"
         alt="картинки нет, но вы держитесь"/>
    <img class="code-snapshot" src="/img/posts/idea-usage/params2.PNG"
         alt="картинки нет, но вы держитесь"/>

</p>

<h4>Ctrl+H</h4>
<p>
    Показывает иерархию классов и интерфейсов, работает в противоположном направлении по сравнению с диаграммой классов.
    Пример для Collection и TreeSet.
</p>

<p>
    <img class="code-snapshot" src="/img/posts/idea-usage/hierarchy1.PNG"
         alt="картинки нет, но вы держитесь"/>
    <img class="code-snapshot" src="/img/posts/idea-usage/hierarchy2.PNG"
         alt="картинки нет, но вы держитесь"/>
</p>

<h4>
    Ctrl+Alt+F7
</h4>
<p>
    Найти использования класса или метода. Удобный способ навигации по коду, также исключительно полезно при рефакторинге.
</p>

<p>
    <img class="code-snapshot" src="/img/posts/idea-usage/usages.png"
         alt="картинки нет, но вы держитесь"/>
</p>

<h4>
    Ctrl+N, Ctrl+Shift+N
</h4>
<p>
    Первая команда ищет класс в проекте по имени, вторая произвольный файл по имени. Просто и понятно, но не все используют и поэтому
    иногда спрашивают где находится файл или в каком пакете класс.
</p>

<h4>Колесико
</h4>
<p>
    Нажатие на среднюю кнопку мыши создаёт многострочный курсор для редактирования текста, причём автодополнения тоже работают. Обожаю эту фишку.
</p>
<p>
    <img class="code-snapshot" src="/img/posts/idea-usage/multiline.PNG"
         alt="картинки нет, но вы держитесь"/>

</p>

<h4>Ctrl+Alt+L</h4>
<p>
    Форматирование текста и кода. Прекрасно работает на файлах XML и JSON, чтобы привести их к структурированному читаемому виду (pretty print).
    Но в основном, конечно, применяется к коду, обычно после завершения каждого блока кода в 5-10 строк.
    В этом случае весь код всегда поддерживается в едином стиле отступов, пробелов и переносов строк. Эстетика!
    Важно, чтобы все разработчики в команде использовали одинаковые настройки форматирования, причём настройки по умолчанию меня полностью устраивают.
    В противном случае в репозитории код будет постоянно переформатироваться туда-сюда.
</p>

<h4>Шаблоны (Live Template)</h4>
<p>
    Шаблоны работают так: в коде вводится несколько символов, потом нажимаем Tab. IDEA вставляет либо готовый код либо шаблон кода, в который нужно подставить переменную.
    Кто-то очень интенсивно использует этот функционал, создавая множество собственных шаблонов. Я пока что использую только 4 встроенных:
</p>

<ol>
    <li><strong>psvm</strong> Создаёт метод main.
        <br>
        <img class="code-snapshot" src="/img/posts/idea-usage/psvm.PNG"
             alt="картинки нет, но вы держитесь"/>
    </li>
    <li><strong>iter</strong> Создаёт foreach цикл. Автоматически подставляет ближайшую коллекцию из контекста, но можно сразу поменять.
        <br>
        <img class="code-snapshot" src="/img/posts/idea-usage/iter.png"
             alt="картинки нет, но вы держитесь"/>
    </li>
    <li><strong>itar</strong> Создаёт классический for цикл по коллекции с использованием индексов элементов.
        <br>
        <img class="code-snapshot" src="/img/posts/idea-usage/itar2.PNG"
             alt="картинки нет, но вы держитесь"/>
    </li>
    <li><strong>itco</strong> Создаёт for цикл по коллекции с использованием iterator.
        <br>
        <img class="code-snapshot" src="/img/posts/idea-usage/itco.PNG"
             alt="картинки нет, но вы держитесь"/>
    </li>
</ol>

<p>
    Конечно, шаблоны для итерации использую всё реже из-за того, что их вытесняют стримы.
</p>

<h3>
    Заключение
</h3>
<p>
    При обучении программированию в целом и Java в частности существуют подходы с написанием кода в текстовом редакторе или в форме на сайте.
    Таким образом оттачивается базовый синтаксис и конструкции. Якобы. Я не поддерживаю эту идею и считаю, что нужно сразу максимально
    приближать обучение к рабочим условиям. А в работе все стараются использовать IDE по максимуму. Тем более, что их возможности сегодня поражают воображение.
    Еще я не упомянул отдельно комбинации Alt+Enter и Ctrl+Space - это способы попросить подсказку у IDEA, либо закончить строчку кода за нас.
    Но думаю эти возможности используют все, ведь подсказки и помощь в IDEA повсюду и осваиваются первым делом.
</p>




