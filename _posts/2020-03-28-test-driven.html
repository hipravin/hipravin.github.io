---
layout: post
title: Тестирование с помощью JUnit
excerpt: Зачем нужны тесты? Тестируем алгоритмы, работу с БД, REST-сервисы, отправку email
---

<p><a href="https://github.com/hipravin/samples-unit-testing">Код примеров</a>.</p>

<p>
    Юнит тестирование - тема для бесконечных споров.
    Сам я считаю написание тестов неотъемлимой частью процесса разработки.
    Они помогают быстрее писать код, повышают его качество.
    Можно выделить два подхода к разработке программ.
    Первый - реализовать задачу полностью, потом проверять и исправлять ошибки (либо особенно не проверяя отдать команде тестирования).
    Второй - проверять функионал по ходу рарзаботки и, когда все компоненты реализованы, получить почти готовое решение.
    Программисты шутят, что если запустил программу в первый раз и она работает, то здесь какой-то подвох.
    Тесты необходимы, чтобы переходить от первого подхода ко второму.
</p>

<p>
    Я использую следующий принцип: есть несколько ситуаций, когда тесты полезны и помогают в разработке.
    Когда я встречаюсь с такой ситуацией, то обычно даже первым делом пишу не код, а тест к нему, либо параллельно.
    Если же хорошего способа проверить код юнит тестом я не вижу, то не трачу слишком много времени, чтобы его придумать.
    Со временем такой "список рецептов" пополняется.
    Конечно, до тестового покрытия 80%, которое статические анализаторы считают минимальным пороговым значением на пятёрку, такой подход не дотягивает.
    Чаще получается что-то в коридоре от 40 до 60 процентов. Чтобы достить 80% нужно изучать отчёт о покрытии кода и писать часто неестественные
    и ненужные тесты. Я встречал getter-setter тесты, которые с помощью reflection вызывают get/set по всем полям класса и сравнивают результат.
</p>

<p>
    В то же время всё относительно. Если бы я разрабатывал криптографические алгоритмы или ядро блокчейн платформы или платёжной системы,
    то ни на какие компромиссы и допущения идти было бы нельзя.
    В таком критическом коде тесты должны проверять все строчки кода, все возможнные сценарии исполнения и входные параметры.
    Но среднестатистический проект - как правило обычное корпоративное приложение наподобие внутренней системы управления заказами.
</p>

<p>
    Далее разберу несколько типовых использований юнит тестов.
</p>

<ol>
    <li><a href="#hamming">Алгоритмы</a></li>
</ol>

<h4 id="hamming">Алгоритмы</h4>

<h5>Сортировка</h5>

<p>
    Реализация алгоритмов, пожалуй, самый яркий пример пользы и даже необходимости юнит тестов.
    У алгоритмов просто нет пользовательского интерфейса, чтобы проверять их другим способом.
    Разве что вводить входные параметры через терминал и распечатывать результат, визуально сравнивая его с ожидаемым.
</p>

<p>
    Справедливо будет отметить, что теория тестирование - сложная наука, которая является полноценным направлением в информационных технологиях.
    Разрабатываются модели, формулируются и доказываются теоремы с целью математически гарантировать корректность работы алгоритма.
    То есть тест не просто проверяет несколько основных сценариев работы алгоритма, вместо этого он гарантирует правильность реализации для любых входных параметров.
    Подобные исследования имеют место в системах, в которых ошибки в коде могут привести к катастрофам.
    Здесь же я рассматриваю простые практические случаи, в которых тест как правило проще реализации, но при этом позволяет исключить очень много ошибок.
</p>

<p>
    Для начала напишем тест, который проверяет алгоритм сортировки. В репозитории это класс CollectionSortTest.
    Сравниваем длину; проверяем, что каждый элемент не больше следующего; суммируем все элементы до и после. Всё!
    Ценность такого теста - простота. Нам не требуются сложные алгоритмы, не требуется много времени на написание
    и не нужно ничего знать о конкретной реализации.
    Да, возможно придумать алгоритм, который изменит данные при сортировке, но пройдёт тест.
    Однако случайно допустить подобную ошибку при реализации алгоритма сортировки практически невозможно.
{% highlight Java %}
    void checkArraySortedCorrectly(long[] original, long[] sorted) {
        long sumOriginal = LongStream.of(original).sum();
        long sumSorted = LongStream.of(sorted).sum();

        assertEquals(original.length, sorted.length);
        assertEquals(sumOriginal, sumSorted);

        for (int i = 1; i < sorted.length; i++) {
            assertTrue(sorted[i-1] <= sorted[i]);
        }
    }
{% endhighlight %}
    Сначала обязательно проверяем, что тест падает при заведомо неправильной реализации, потом - что он проходит при верной.
{% highlight Java %}
    @RepeatedTest(100)
    void testArraysNotSorted() {
        long[] original = randomLongArray(100_000);
        long[] sorted = copy(original);
        Arrays.sort(sorted);
        sorted[1] = sorted[0];//имитируем ошибку в результате

        assertThrows(AssertionFailedError.class, () -> {
            checkArraySortedCorrectly(original, sorted);
        });
    }
    @RepeatedTest(100)
    void testArraysSort() {
        long[] original = randomLongArray(100_000);
        long[] sorted = copy(original);
        Arrays.sort(sorted);

        checkArraySortedCorrectly(original, sorted);
    }

{% endhighlight %}
</p>

<p>
    Имеет смысл при тестировании алгоритмов проверить граничные случаи: пустой массив, массив из одного элемента, уже отсортированный, обратно отсортированный,
    массив одинаковых элементов. А после - много раз проверить на большом наборе случайных данных.
</p>

<h5>Код Хэмминга</h5>

<p>
    Код Хэмминга - один из алгоритмов избыточного кодирования данных для передеачи через ненадёжные каналы, подверженные случайным ошибкам.
    Позволяет исправлять ошибку в передаче одного бита входного сообщения, требуя порядка log(n) бит избыточности.
    Алгоритм относительно сложный и я здесь не привожу его описания.
    Предлагаю написать тесты, даже не изучая сам алгоритм, а лишь требования, то есть задачу, которую он решает.
    Такой подход к тестированию называют методом чёрного ящика. Когда реализация достпуна, то имеем метод белого ящика.
</p>

<p>
    Реализация будет работать с последовательностью бит, кратной байту, хотя оригинальный алгоритм этого не требует.
    Для декодирования требуется знать размер исходного сообщения, потому что по закодированному сообщению. определить его однозначно нельзя.
    Зафиксируем интерфейс и можно приступать к тесту.
{% highlight Java %}
    byte[] encode(byte[] source);
    byte[] decode(byte[] encoded, int sourceSizeBytes);
{% endhighlight %}
</p>

<p>
    Вот что у меня получилось.
    Я реализовал два рандомизированных теста - первый проверяет работу алгоритма без искажения данных, второй при инверсии одного случайного бита.
{% highlight Java %}

    @RepeatedTest(100)
    void encodeDecodeNoBrokenBits() {
        int length = random.nextInt(10_000) + 1;
        byte[] original = randomByteArray(length);
        byte[] thereAndBackAgain = encoder.decode(encoder.encode(original), original.length);

        assertArrayEquals(original, thereAndBackAgain);
    }

    @RepeatedTest(100)
    void encodeDecodeRandomBrokenBits() {
        int length = random.nextInt(10_000) + 1;
        byte[] original = randomByteArray(length);
        byte[] encoded = encoder.encode(original);

        invertRandomBit(encoded);
        byte[] thereAndBackAgain = encoder.decode(encoded, original.length);

        assertArrayEquals(original, thereAndBackAgain);
    }
{% endhighlight %}
    После того, как реализация алгоритма была закончена и эти два теста начали проходить, я решил ещё на всякий случай добавить проверку,
    что тест не проходит, если поменять два бита вместо одного.

{% highlight Java %}
    @RepeatedTest(100)
    void encodeDecodeRandom2BrokenBits() {
        int length = random.nextInt(10_000) + 1;
        byte[] original = randomByteArray(length);
        byte[] encoded = encoder.encode(original);

        setBit(encoded, 0, bitAt(encoded, 0) ^ 1);
        setBit(encoded, 1, bitAt(encoded, 1) ^ 1);

        byte[] thereAndBackAgain = encoder.decode(encoded, original.length);
        assertThrows(AssertionFailedError.class, () -> {
            assertArrayEquals(original, thereAndBackAgain);
        });
    }
{% endhighlight %}
    Кроме этих тестов в процессе реализации я использовал небольшие "тестики" для проверки простых, но критических
    функций наподобие манипулирования с битами в массиве байт. В таких тестах можно использовать и отладочную печать, но
    при коммите в репозиторий лучше её убирать.
</p>

<p>
    Как обычно, полная версия кода есть <a href="https://github.com/hipravin/samples-unit-testing">в репозитории.</a>.
    Не скажу, что код идеальный, потому что, как говорил мой коллега, "код бывает только плохой и ещё не написанный".
    На случай, если кто-то будет изучать сам алгоритм и реализовывать его, отмечу несколько недочётов, которые допущены в реализациях,
    которые нашлись первыми по запросу "hamming code implementation java".
    Эти недочёты не связаны с работой алгоритма, а только со стилем написания кода и используемыми приёмами.
    Когда перед интервью вас просят решить тестовую задачу, проверяющий в первую очередь оценивает общее качество кода,
    а уже во вторую - правильность алгоритма. Итак, что мне не понравилось в большинстве реализаций:
</p>

<ol>
    <li>
        Манипулирование битами с помощью строковых операций (например, Integer.toBinaryString(k), charAt).
        Это крайне неэффективно и я считаю грубой ошибкой.
        Такие операции можно использовать в тестах, чтобы код теста был более выразительным и читаемым.
    </li>
    <li>
        Упрощение задачи. Вместо заморочек с битовыми операциями, вводится массив int[], в котором каждый элемент соответствует одному биту.
        Потребление памяти в 32 раза больше оптимального.
    </li>
    <li>
        Смешивание всего в одну кучу - один большой метод main, который реализует алгоритм, запрашивает входные данные,
        печатает промежуточные шаги, печатает результат и т.д.
        Такой код на один раз, чтобы разобраться с алгоритмом.
    </li>
</ol>