---
layout: post
title: SQL Injection java PostgreSQL TODO
excerpt: SQL Injection java PostgreSQL TODO
metadescription: TODO
---
<p><a href="https://github.com/hipravin/samples-sql-injection">Код примеров на Github</a>.</p>
<h4>
    Вступление
</h4>
<p>
    В данной статье речь пойдёт о таком типе уязвимости приложений как внедрение SQL кода (SQL injection / SQL-инъекция).
    Информации по данной теме в сети очень много, как в общем, так и с учётом специфики Java разработки:
</p>
    <ul>
        <li><a href="https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html">
            SQL Injection Prevention Cheat Sheet</a></li>
        <li><a href="https://bi.zone/expertise/insights/chem-opasny-sql-inektsii-i-kak-ot-nikh-zashchititsya/">Чем опасны SQL-инъекции и как от них защититься</a></li>
        <li><a href="https://sec.okta.com/articles/2020/12/sql-injection-java-practices-avoid">SQL Injection in Java: Practices to Avoid</a></li>
        <li><a href="https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/05-Testing_for_SQL_Injection">
            Testing for SQL Injection</a></li>
    </ul>
<p>
    Суть уязвимости в том, что злоумышленник вместо простого текста, в котором система ожидает его имя, адрес, поисковый запрос и так далее,
    вводит специальные символы и обрывки SQL кода. Этот текст служит параметром какого-то SQL запроса в приложении.
    Если приложение уязвимо, то исходный SQL запрос удаётся подменить.
    Это может позволить получить информацию, к которой пользователь не имеет доступа, изменить данные ради своей выгоды,
    а также полностью уничтожить данные.
</p>
<p>
    Кроме чудовищной опасности данной уязвимости, удивительна и лёгкость, с которой ей можно воспользоваться:
    не требуется специальных инструментов и сложных навыков, не нужен физический доступ к серверу или поддельный сайт.
</p>
<p>
    С другой стороны, в мире Java разработки существует несколько простых правил, позволяющих практически полностью исключить
    возможности внедрения SQL:
</p>
<ol><li>
        Не использовать конкатенацию строк в запросах к базам данных.
    </li>
    <li>
        Использовать PreparedStatement/CallableStatement вместо Statement.
        Библиотеки spring-jdbc, Hibernate, MyBatis, JOOQ и прочие также внутри используют PreparedStatement.
    </li>
    <li>
        Передавать параметры запросов с помощью методов setParameter, а не в самом запросе. (Автоматически следует из первых двух правил.)
    </li>
</ol>
<p>
    Первое правило может быть ослаблено, чтобы запрет конкатенации касался только параметров запроса, но
    ради выразительности и читаемости кода я предпочитаю его в таком виде.
</p>
<p>
    Существуют и другие причины всегда писать программы следуя этим требованиям: корректность передачи параметров различных типов,
    производительность, краткость и выразительность кода.
    Поэтому кажется, что большинство разработчиков уже следует этим правилам и риск подверженности SQL-инъекциям в Java приложениях преувеличен.
    К сожалению, контрпримеры существуют, и поэтому сохраняется необходимость в повышенном внимании к данной проблеме.
    Например, на первой же странице поиска по Github c запросом "createStatement( ' language:java" мне удалось найти код в серьёзном проекте, потенциально подверженный внедрению SQL:

    <a href="https://github.com/stanfordnlp/CoreNLP/blob/3499d27e615c35702f23948e886a7389b5695c33/src/edu/stanford/nlp/util/GoogleNGramsSQLBacked.java#L101">github.com/stanfordnlp/CoreNLP... </a>
    {% highlight java %}
    if(str.contains("'")){
       str = StringUtils.escapeString(str, new char[]{'\''},'\'');
    }
    ...
    String phrase = escapeString(str);
    query = "select count from " + table + " where phrase='" + phrase+"';";{% endhighlight %}
    Возможно, автор предпринял усилия для защиты кода с помощью экранирования, но выбранный метод не является рекомендованным и надежным.
    Подробнее позже, иначе вступление будет слишком громоздким.
</p>
<p>
    Я хочу провести несколько экспериментов, чтобы выяснить на практике, насколько просто получится воспроизвести уязвимость и устранить её,
    насколько критичен возможный ущерб, а также как обнаружить незащищенный код. Подопытной базой данных будет PostgreSQL,
    а в качестве клиента - Spring Jdbc (JdbcTemplate) и JPA (Hibernate).
</p>

<h4>Тестовый проект</h4>
<p>
    Изучение уязвимости я буду проводить исключительно на слое работы с базой данных, то есть в рамках реализации DAO (Data Access Object) классов.
    В контексте веб-приложений контроллер или сервисный класс также может содержать логику проверки параметров (validate, sanitize),
    что безусловно снижает риск различных ошибок, в том числе косвенно и сценариев внедрения SQL.
    Это хорошая практика, но реализация DAO должна быть сама по себе устойчива к атакам.
</p>

<p>
    Для начала рассмотрю самый простой и классический сценарий: поиск на равенство по строковому полю.
    Для иллюстрации принципов возникновения SQL-инъекций и защиты от них этого будет достаточно.
</p>
    {% highlight sql %}
    CREATE TABLE BOOK (
        ID BIGSERIAL PRIMARY KEY,
        TITLE TEXT NOT NULL,
        CONSTRAINT name_length CHECK (length(TITLE) <= 512));  {% endhighlight %}
<p>
    Предположительно, в приложении существует необходимость искать книгу по точному совпадению названия,
    которое пользователь вводит на сайте в текстовом поле. На уровне DAO это означает выполнение такого кода:
</p>
    {% highlight java %}
    public List<BookEntity> findByTitle(String title) {
        String query = "select * from book where title = '" + title + "'";
        return jdbcTemplate.query(query, BOOK_ROW_MAPPER);
    } {% endhighlight %}
<p>
    При использовании конкатенации строк в реализации возможно в названии книги указать символ одинарной кавычки, а далее прервать запрос,
    изменить условие поиска, выполнить произвольный запрос. Нужно лишь, чтобы результирующий SQL скрипт был синтаксически корректен, что
    достигается просто и элегантно: title =
</p>
    {% highlight plaintext %}
    ' or '1'='1
    ';truncate book;
    ';truncate book; select '1    {% endhighlight %}
<p>
    Первое значение позволяет заменить условие поиска на безусловно верное, то есть получить всё содержимое таблицы.
    Второе приводит к неверному синтаксису запроса, потому что кавычка не закрыта, в результате чего он не выполняется. Но если его немного поправить, как в третьем случае,
    то очищается содержимое таблицы book. Это самый опасный вариант, в котором можно писать произвольные запросы, ограниченные лишь фантазией взломщика
    и правами пользователя базы данных.
</p>
<p>
    В тестовом проекте попытка выполнить метод с параметром title = "';truncate book; select '1" изначально была успешна и,
    несмотря на исключение ниже, таблица очищалась. Исключение выбрасывается уже после успешного выполнения скрипта потому
    что JdbcTemplate ожидает только один результат, а на самом деле их несколько, ведь мы превратили один запрос в три.
</p>
    {% highlight plaintext %}
    org.springframework.dao.DataIntegrityViolationException:
        StatementCallback; SQL [select * from book where title = '';truncate book; select '1'];
        Multiple ResultSets were returned by the query.
    {% endhighlight %}
<p>
<p>
    После добавления аннотации @Transactional в классе JdbcBookRepositoryImpl очищение таблицы больше не происходит.
    Поведение программы при атаке стало таким:
</p>
<ol>
    <li>Атака изменяет запрос на такой: select * from book where title = '';truncate book; select '1'</li>
    <li>Запрос успешно выполняется</li>
    <li>При обработке результатов выполнения запроса выбрасывается исключение</li>
    <li>Транзакция откатывается</li>
</ol>
<p>
    Можно сказать, что благодаря правильному использованию JdbcTemplate и Spring, вред от атаки удалось существенно уменьшить.
</p>
<p>
    Реализация с использованием JPA при включении параметров в запрос с помощью конкатенации строк также подвержена внедрению SQL:
</p>
    {% highlight java %}
    @Override
    public List<BookEntity> findByTitle(String title) {
        String jpqlQuery = "select b from BookEntity b where b.title = '" + title + "'";
        var query = em.createQuery(jpqlQuery, BookEntity.class);
        return query.getResultList();
    }{% endhighlight %}

<p>
    Хотя в этом случае атака сложнее: нужно действовать в рамках синтаксиса JPQL запросов, желательно знать имена классов и свойств.
    Синтаксис более строгий и менее функциональный.
    Из вышеперечисленных атак удаётся только изменение условия на полную выборку (title = "' or '1'='1").
    Попытка завершить запрос и выполнить другой приводит к исключению:
</p>
    {% highlight java %}
    title = "';delete from BookEntity where '1'='1"

    org.springframework.dao.InvalidDataAccessApiUsageException: org.hibernate.query.SyntaxException:
      At 1:45 and token ';', mismatched input ';'...
    {% endhighlight %}

<h4>
    Экранирование
</h4>
<p>
    Справедливо отметить, что реализации, рассмотренные ранее, не только уязвимы к внедрению SQL, но и вообще не полностью корректны.
    Поиск книг, содержащих апостроф (например, O'Reilly), приводит к некорректному синтаксису запроса. Это общая проблема представления текстовой информации:
    в URL, Html, CSS, Json, yaml и т.д. существуют служебные символы, которые необходимо экранировать. В Java чтобы включить в строковую константу символ двойной кавычки
    нужно использовать символ обратного слэша ("\""). В html чтобы отобразить символы '<' или '>' используются конструкции &amp;lt; и &amp;gt;.
    Иными словами, задача экранирования служебных символов встречается повсеместно. Решение исключительно прямолинейно: изучить формат представления текста,
    идентифицировать логику экранирования и... использовать библиотеку, в которой всё уже реализовано.
    Например, для html подойдут apache-commons, guava, HtmlUtils в Spring, OWASP encoder.
    Для экранирования одинарной кавычки в SQL запросе в соответствии со стандартом нужно её удвоить ('').
    В некоторых СУБД также используется обратный слэш (\').
</p>
    {% highlight java %}
    @Override
    public List<BookEntity> findByTitle(String title) {
        String query = "select * from book where title = '" + escapeQuotes(title) + "'";
        return jdbcTemplate.query(query, BOOK_ROW_MAPPER);
    }

    static String escapeQuotes(String value) {
        return (value != null) ? value.replace("'", "''") : null;
    }  {% endhighlight %}
<p>
    Такая реализация корректно обрабатывает поиск книг с апострофом в названии и не подвержена SQL-инъекциям, по крайней мере тем,
    которые я пробовал ранее. Существует ли способ сломать такую защиту? Возможно. Точного ответа на этот вопрос найти не удалось, но многие сходятся в выводе,
    что такой метод защиты ненадежен и не рекомендован. В одной старой презентации на сайте OWASP описывается как можно обойти экранирование
    апострофа: <a href="https://owasp.org/www-pdf-archive/OWASP_IL_2007_SQL_Smuggling.pdf">https://owasp.org/www-pdf-archive/OWASP_IL_2007_SQL_Smuggling.pdf</a>.
    Для этого используется символ апострофа в какой-то нестандартной локали, который может быть преобразован автоматически в нормальный на стороне базы данных,
    минуя проверку в коде программы: (U+02BC -> U+0027).
    Разобраться в деталях безумно интересно, но слишком уводит в сторону от основной темы.
</p>
<p>
    Можно ли реализовать тот же приём, но с использованием проверенной надёжной библиотеки, учитывающей все служебные символы и отличия разных СУБД?
    Судя по всему, нет. Существует библиотека OWASP Esapi, которая, кроме прочего, призвана решить эту задачу и даже иногда применяется на практике:
</p>
    {% highlight java %}
    static String escapeSpecialCharacters(String value) {
        //available codecs: MySQL, DB2, Oracle. But there is no PostgreSQL codec!
        return ESAPI.encoder().encodeForSQL(new OracleCodec(), value);
    } {% endhighlight %}
<p>
    Кодека для PostgreSQL нет, но реализация OracleCodec выполняет в точности то же, что функция escapeQuotes выше.
    Поэтому код работает, хотя выглядит очень странно - база данных ведь не Oracle, а PostgreSQL!
</p>
<p>
    Причина, по которой я рассмотрел экранирование как возможное решение в том, что такой подход можно встретить.
    Например, в старом унаследованном коде. Предполагаю, что когда-то
    во многих проектах массово использовалась конкатенация строк для включения параметров в запросы.
    Потом в какой-то момент приходилось так же массово добавлять экранирование, потому что требовалось внести правки
    быстро и с минимальными изменениями, а переписывать код на использование параметризованных
    запросов намного более затратное и рискованное мероприятие. Не буду дальше углубляться в эту тему и перейду
    к правильному и общепринятому решению - параметризованным запросам.
</p>
<h4>
    Параметризованные запросы
</h4>
<p>
    Параметризованные запросы - концепция, которая противопоставляется динамически генерируемым запросам.
    Для вторых каждый раз, когда нужно выполнить поиск, система выполняет все шаги: формирование запроса конкатенацией,
    доставка запроса до базы данных средствами JDBC драйвера. На стороне БД: синтаксический разбор запроса, применение правил (rewrite system),
    оптимизация и выбор плана выполнения, выполнение.
</p>
<p>
    Для параметризованных запросов на всех уровнях реализовано разделение статического запроса и его динамических параметров:
</p>
<ol>
    <li>В Java коде: connection.prepareStatement(..) отделено от pstmt.setParameter(...) </li>
    <li>Драйвер базы данных передает параметры отдельно от запроса</li>
    <li>База данных выделяет параметры из запроса и кэширует план выполнения без учета параметров</li>
</ol>
<p>
    Используя такой подход, мы как разработчики, полагаемся на корректность реализации классов и библиотек Java, JDBC драйвера и самой СУБД.
    В контексте SQL-инъекций для работы такого понимания достаточно, но, безусловно, за внешней простотой скрывается большое количество тонкостей и нюансов.
    Например, в PostgreSQL существуют серверные параметризованные запросы, требующие пары запросов PREPARE - EXECUTE.
    Драйвер выбирает, сколько запросов кэшировать и в какой момент переходить с клиентского на серверный варианты.
    По умолчанию, четыре запроса будут клиентскими, а последующие - серверными. Изменть данное поведение можно вызовом метода pgStatement.setPrepareThreshold(...);
    Подробнее можно почитать здесь <a href="https://dev.to/yugabyte/postgres-query-execution-jdbc-prepared-statements-51e2">
    https://dev.to/yugabyte/postgres-query-execution-jdbc-prepared-statements-51e2</a>
</p>

<p>
    Далее приведу несколько реализаций с использованием параметризованных запросов. Все они корректны и не подвержены внедрению SQL.
    Работу непосредственно с Connection и PreparedStatement без использования вспомогательных библиотек я пропускаю - такой код слишком многословен,
    требует большого внимания к корректному управлению ресурсами (ResultSet, Statement и Connection), поэтому подвержен ошибкам.
</p>
<p><strong>Spring JdbcTemplate</strong></p>
    {% highlight java %}
    public List<BookEntity> findByTitle(String title) {
        String query = "select * from book where title = ?";
        return jdbcTemplate.query(query, ps -> ps.setString(1, title),
            BOOK_ROW_MAPPER);
    }  {% endhighlight %}
<p><strong>JPA EntityManager, Named Query</strong></p>
    {% highlight java %}
    @Entity
    @Table(name = "BOOK")
    @NamedQueries({
         @NamedQuery(name = "BookEntity.findByTitle",
            query="select b from BookEntity b where b.title = :title")
    })
    public class BookEntity {
    ...
    @Override
    public List<BookEntity> findByTitle(String title) {
        var query = em.createNamedQuery("BookEntity.findByTitle", BookEntity.class);
        query.setParameter("title", title);
        return query.getResultList();
    } {% endhighlight %}
<p><strong>Spring Data query methods, @Query</strong></p>
    {% highlight java %}
    public interface SpringDataBookRepository extends JpaRepository<BookEntity, Long> {
        List<BookEntity> findByTitle(String title);

        @Query("select b from BookEntity b where b.title = :title")
        List<BookEntity> findByTitleExplicitJpql(String title);
    }{% endhighlight %}

<p>
    Синтаксис отличается, но во всех случаях присутствует общая семантика: параметр title отделён от запроса.
    Существует ещё множество способов доступа к данным в Java, можно использовать любой наиболее подходящий конкретному приложению.
    Снова возникает резонный вопрос - почему столько внимания уделяется SQL-инъекциям,
    если лучшее решение - просто применение современных подходов к работе с данными?
</p>

<h4>А есть ли проблема?</h4>
<p>
    Согласно  <a href="https://www.statista.com/statistics/806081/worldwide-application-vulnerability-taxonomy/#:~:text=SQL%20Injection%20is%20the%20main,site%20scripting%20(stored)%20attacks.">
    сайту www.statista.com</a>,
    23% всех критических уязвимостей в 2023 года относится к SQL-инъекциям, удерживающим лидерство в таблице.
    По другому отчёту 29% всех приложений всё ещё уязвимы к подобным атакам (Imperva Web Application Attack Report, WAAR, February 2020).
    Причин может быть много: унаследованный код, устаревшие примеры кода в сети, экономия.
    Возможно, что среди приложений на Java статистика выглядит лучше среднего, а на PHP - хуже.
    Но уже понятно, что в рамках мировой IT инфраструктуры проблема внедрения SQL сохраняется.
    Теперь следующий важный вопрос - а есть ли проблема у конкретного программиста?
    Как убедиться, что код, который добавляется в систему безопасен? Как убедиться, что нет старого кода, который уязвим?
    Как доказать начальству или внешнему аудиту, что приложение не подвержено данному типу атак?
</p>

<p>
    В случае с новым кодом помогает процесс рецензирования (code review).
    Старый код тоже следует изучить и по возможности привести в соответствие со стандартами, принятыми в компании.
    Если старый код содержит большое количество потенциальных кандидатов для SQL-инъекций, и этом он плохо покрыт регрессионным тестированием,
    то можно применить экранирование, чтобы снизить риски атак до полноценного рефакторинга.
    Для полноценного аудита и уверенности в защищенности приложения применяются специальные инструменты, сканирующие код на предмет уязвимостей.
    Часть из них направлена на поиск уязвимостей методом черного ящика. Такие инструменты производят стандартные атаки на работающем приложении и
    собирают отчет из всех удачных попыток. Другая часть сканирует исходные файлы приложения, не требуя его запуска.
    Наверное, самый известный такой инструмент для Java - это SonarQube.
</p>

<h4>Поиск уязвимостей с помощью SonarQube</h4>
<p>
    К сожалению, публичная версия SonarQube не обнаруживает SQL-инъекции.
    Другой мощный инструмент - VeraCode - вообще не имеет публичной версии.
    Возможно, удастся заполнить данный раздел позже.
    Хотелось бы проверить, сколько уязвимостей будет обнаружено в тестовом проекте, а также
    посчитает ли SonarQube экранирование достаточной защитой.
</p>


<h4>LIKE injection</h4>
<p>
    Используя параметризованные запросы, об SQL-инъекциях можно забыть. Такое заявление я встретил в одной из статей в сети.
    Давайте порассуждаем, насколько справедливо такое утверждение.
    Действительно, такой подход надежно защищает от классического "полноценного" внедрения SQL с подменой условия, прерыванием запроса,
    превращением его в синтаксически некорректный.
    С другой стороны, иногда сам параметр может содержать в себе служебные символы, которые в зависимости от логики работы приложения,
    разрешено или запрещено вводить пользователю.
    Например, запросы с оператором LIKE могут содержать символы подстановки (wildcard) '%' или '_'. Предположим, что в программе есть функционал поиска книги по первым символам названия, то есть
    по префиксу поля title.
    С точки зрения SQL это означает выполнение следующего запроса:
</p>
{% highlight sql %}
    select * from book where title like 'Some Title%';    {% endhighlight %}
<p>
    'Some Title' - значение, которое вводит пользователь, а '%' в конце программа добавляет самостоятельно.
    Пользователь может сам использовать символы подстановки, например, так: '%Java'. Тогда в результате вместо поиска
    по префиксу будет произведён поиск по подстроке. В отдельных случаях это может быть разрешено намеренно в качестве функциональности расширенного поиска.
    Но в большинстве случаев это ошибка и потенциальная уязвимость. Кроме неверных результатов поиска может пострадать производительность запросов:
    самый распространённый тип индекса btree работает при поиске по началу строки, но никак не помогает при поиске по подстроке.
    Существуют другие типы индексов, которые помогут, если нужен именно поиск по подстроке, подробнее можно почитать здесь
    <a href="https://www.cybertec-postgresql.com/en/postgresql-more-performance-for-like-and-ilike-statements/">https://www.cybertec-postgresql.com/en/postgresql-more-performance-for-like-and-ilike-statements/</a>.
    Но будем исходить из того, что разрешён лишь поиск по префиксу и служебные символы нужно запретить или экранировать.
    Экранирование означает добавление обратной косой черты перед символами подстановки: '\%' и '\_':
</p>
{% highlight plaintext %}
    select * from book where title like 'What if \% or \_ is present in the title?' escape '\';
    select * from book where title like 'What if |% or |_ is present in the title?' escape '|'; {% endhighlight %}

<p>
    Конструкция "escape '\'" позволяет выбрать символ экранирования, что необязательно для PostgreSQL если '\' нам подходит.
    Однако стандарт SQL не предусматривает никакого символа экранирования по умолчанию, поэтому так код становиться более универсальным.
    В частности, такие запросы можно выполнять одновременно на тестовой HSQLDB и эксплуатационной PostgreSQL.
</p>

<p>
    Предлагаю для всех использованных ранее способов доступа к базе данных реализовать поиск по началу названия книги.
    Для экранирования будет использована функция escape из модуля spring-data.
</p>
<p><strong>Spring JdbcTemplate</strong></p>
    {% highlight java %}
    @Override
    public List<BookEntity> findByTitleStartingWithOrderByTitle(String prefix) {
        String query = "select * from book where title like ? escape '\\' order by title";
            return jdbcTemplate.query(query,
            ps -> ps.setString(1, EscapeCharacter.DEFAULT.escape(prefix) + "%"),
            BOOK_ROW_MAPPER);
    }  {% endhighlight %}
    <p><strong>JPA EntityManager, Named Query</strong></p>
    {% highlight java %}
    ...
    @NamedQuery(name = "BookEntity.findByTitlePrefix",
        query="select b from BookEntity b where b.title like :titlePrefix escape '\\' order by b.title")
    ...
    @Override
    public List<BookEntity> findByTitleStartingWithOrderByTitle(String prefix) {
        var query = em.createNamedQuery("BookEntity.findByTitlePrefix", BookEntity.class);
        query.setParameter("titlePrefix", EscapeCharacter.DEFAULT.escape(prefix) + "%");
        return query.getResultList();
    } {% endhighlight %}
    <p><strong>Spring Data query methods, @Query</strong></p>
    {% highlight java %}
    List<BookEntity> findByTitleStartingWithOrderByTitle(String title); //implicitly escapes % and _

    @Query("select b from BookEntity b where b.title like ?#{escape([0])}% escape ?#{escapeCharacter()} order by b.title")
    List<BookEntity> findByTitleStartingJpql(String prefix); {% endhighlight %}
<p>
    В примерах с использованием JdbcTemplate и EntityManager-NamedQuery добавлен явный вызов функции escape.
    Spring Data @Query требует довольно громоздкого выражения, которое к тому же не валидируется текущей версии IDE, но всё же работает корректно.
    Интереснее всего тот факт, что Spring Data Query Methods производит экранирование неявно.
    Такое поведение справедливо для методов 'StartingWith', 'EndingWith', 'Containing', 'NotContaining', причём судя по исходному коду текущей версии не похоже,
    чтобы его можно было отключить в конфигурации (см. класс org.springframework.data.jpa.repository.query.ParameterMetadataProvider).
</p>

<h4>Regular expression injection</h4>
<p>
    Если речь зашла о внедрении SQL в LIKE запросы, то следует отметить, что такая же проблема будет актуальна для запросов типа title ~ 'expr' и 'title SIMILAR TO expr'.
</p>
    {% highlight sql %}
    select * from book where title ~ '^S{1,3}.+\d+$'; {% endhighlight %}
<p>
    Регулярное выражение обычно выполняется быстро, но может быть сформулировано так, чтобы потреблять произвольный объём памяти и времени исполнения.
    Правильное экранирование всех служебных символов в регулярном выражении также выглядит слишком сложной и потому сомнительной задачей.
    Думаю разумно в данном случае избегать сценариев, в которых введённый пользователем текст напрямую используется в запросе.
    Можно разрешить вводить строго типизированные данные или вообще выбирать только из списка разрешённых значений.
    Общие рекомендации по разработке защищенных приложений включают внимательное отношение к любым данным, приходящим от пользователя.
    Уязвимость log4shell показала, что опасность может представлять даже такая невинная операция как логирование.
</p>

<h4>
    Динамические запросы
</h4>
<p>
    Рассмотрим ещё один сценарий, который заслуживает внимания и связан с SQL-инъекциями.
    Речь пойдёт о запросах, в которых набор условий формируется в процессе выполнения.
    Например, из нескольких параметров нужно выбрать только те, которые заполнены.
    Подобные сценарии периодически возникают на практике и удачно, что на stackoverflow существует как раз такой вопрос:
    <a href="https://stackoverflow.com/questions/59855519/cannot-mitigate-sql-injections-using-owasp-esapi-veracode">https://stackoverflow.com/questions/59855519/cannot-mitigate-sql-injections-using-owasp-esapi-veracode</a>
    Автор вопроса использует StringBuilder для построения запроса. Статический анализатор кода VeraCode выявил уязвимость такого кода, после чего разработчик попытался использовать
    библиотеку OWASP Esapi для обработки пользовательского ввода и защиты от SQL-инъекций.
    Это не помогло, и в качестве рекомендаций все единогласно посоветовали не использовать конкатенацию и воспользоваться параметризованными запросами.
</p>

<p>
    Рассмотрим несколько вариантов решения подобной задачи.
    Применительно к тестовому проекту сформулируем её так: найти книги, названия которых содержат хотя бы одно из указанных значений.
    Запрос будет выглядеть так:
</p>
{% highlight sql %}
    select * from book where title like '%term1%' or title like '%term2%' or title like '%term3%'; {% endhighlight %}
<p>
    Напрашивается прямолинейное решение с конкатенацией строк и методом Stream#collect.joining:
</p>
    {% highlight java %}
    @Override
    public List<BookEntity> findByTitleLikeOr(String... orLikeTitles) {
        String likePart = Arrays.stream(orLikeTitles)
            .map(t -> String.format("title like '%%%s%%' escape '\\'", escape(t)))
            .collect(Collectors.joining(" or "));

        String query = "select * from book where " + likePart + "order by title";
        return jdbcTemplate.query(query, BOOK_ROW_MAPPER);
    } {% endhighlight %}
<p>
    Такой код подвержен внедрению SQL, что можно исправить экранированием кавычек вручную или с использованием OWASP Encoder.encodeForSQL(...).
    Как мы уже знаем, этот способ не рекомендуется и статические анализаторы кода, вероятно, не воспринимают его всерьёз.
    Можно попробовать выйти из положения малой кровью: оставить конкатенацию, но параметры передавать при помощи PreparedStatement:
</p>
    {% highlight java %}
    @Override
    public List<BookEntity> findByTitleLikeOr(String... orLikeTitles) {
        String likePart = Stream.generate(() -> "title like ? escape '\\'")
            .limit(orLikeTitles.length)
            .collect(Collectors.joining(" or "));
        String query = "select * from book where " + likePart + " order by title";

        return jdbcTemplate.query(query, ps -> {
            for (int i = 0; i < orLikeTitles.length; i++) {
                String titlePartEscaped = String.format("%%%s%%", EscapeCharacter.DEFAULT.escape(orLikeTitles[i]));
                ps.setString(i + 1, titlePartEscaped);
            }
        }, BOOK_ROW_MAPPER);
    } {% endhighlight %}
<p>
    Просто формируем запрос типа "... like ? or like ? or like ?...", а затем вызываем метод setParameter нужное количество раз.
    Код работает корректно и защищён от внедрения SQL.
    Но его не назвать очень лаконичным и понятным, кроме того неизвестно как его воспримут статические анализаторы.
    ДLаже если сейчас уязвимость не будет обнаружена, в будущем может появиться более строгая проверка.
    В таком случае можно провести внимательное рецензирование кода и исключить найденную потенциальную уязвимость как ложно положительную.
    Это очень неудобно, если Вы не сами принимаете решение, а отчитываетесь, например, перед внешним аудитом,
    потому что нужно идти по списку потенциальных уязвимостей и демонстрировать каждый отрывок кода, объясняя корректность его работы.
    Как на экзамене. К счастью, есть способ решения задачи, который намного лучше подходит для динамических запросов - JPA Criteria API.
    Тогда код будет выглядеть, например, следующим образом:
</p>
    {% highlight java %}
    @Override
    public List<BookEntity> findByTitleLikeOr(String... orLikeTitles) {
        CriteriaBuilder cb = em.getCriteriaBuilder();
        CriteriaQuery<BookEntity> cq = cb.createQuery(BookEntity.class);
        Root<BookEntity> bookRoot = cq.from(BookEntity.class);
        cq.select(bookRoot);

        var orLikePredicates = Arrays.stream(orLikeTitles)
            .map(t -> cb.like(bookRoot.get("title"), "%" + escape(t) + "%", '\\'))
            .toArray(Predicate[]::new);

        cq.where(cb.or(orLikePredicates));
        cq.orderBy(cb.asc(bookRoot.get("title")));
        TypedQuery<BookEntity> q = em.createQuery(cq);
        return q.getResultList();
    } {% endhighlight %}
<p>
    Субъективно минус Ctiteria API в том, что логика выборки данных размазана по нескольким строчкам кода, а не собрана в единый запрос.
    Поэтому по возможности я предпочитаю использовать SQL или JPQL запросы.
    Чтобы избежать конкатенации можно создать несколько константных запросов и выбирать подходящий условным оператором if
    или конструкцией switch в зависимости от комбинации параметров.
    Но это разумно только если таких констант понадобится две, три, максимум - четыре,
    и такой подход быстро выйдет из-под контроля при добавлении новых условий и параметров.
</p>

<h4>Заключение</h4>
<p>
    В данной статье мы рассмотрели одну из самых опасных и часто встречающихся уязвимостей при разработке приложений,
    работающих с базой данных и получающих какую-то информацию от пользователя.
    Выяснили, что правильный способ защиты - использование параметризованных запросов.
    Было показано, как реализовать такой способ с применением различных библиотек.
    Но это не является "серебрянной пулей" и к данным, полученным от пользователя, всегда стоит относиться с пристрастием.
    Дополнительной мерой защиты может служить экранирование служебных символов.
</p>

<p><a href="https://github.com/hipravin/samples-sql-injection">Код примеров на Github</a>.</p>