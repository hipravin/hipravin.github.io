---
layout: post
title: SQL Injection java PostgreSQL TODO
excerpt: SQL Injection java PostgreSQL TODO
metadescription: TODO
---
<p><a href="https://github.com/hipravin/samples-sql-injection">Код примеров на Github</a>.</p>
<h4>
    Вступление
</h4>
<p>
    В данной статье речь пойдёт о таком типе уязвимости приложений как внедрение SQL кода (SQL injection / SQL-инъекция).
    Информации по данной теме в сети очень много, как в общем, так и с учётом специфики Java разработки:
</p>
    <ul>
        <li><a href="https://bi.zone/expertise/insights/chem-opasny-sql-inektsii-i-kak-ot-nikh-zashchititsya/">Чем опасны SQL-инъекции и как от них защититься</a></li>
        <li><a href="https://sec.okta.com/articles/2020/12/sql-injection-java-practices-avoid">SQL Injection in Java: Practices to Avoid</a></li>
        <li><a href="https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/05-Testing_for_SQL_Injection">
            Testing for SQL Injection</a></li>
    </ul>
<p>
    Суть уязвимости в том, что злоумышленник вместо простого текста, в котором система ожидает его имя, адрес, поисковый запрос и так далее,
    вводит специальные символы и обрывки SQL кода. Этот текст служит параметром какого-то SQL запроса в приложении.
    Если приложение уязвимо, то исходный SQL запрос удаётся подменить.
    Это может позволить получить информацию, к которой пользователь не имеет доступа, изменить данные ради своей выгоды,
    а также полностью уничтожить данные.
</p>
<p>
    Кроме чудовищной опасности данной уязвимости, удивительна и лёгкость, с которой ей можно воспользоваться:
    не требуется специальных инструментов и сложных навыков, не нужен физический доступ к серверу или поддельный сайт.
</p>
<p>
    С другой стороны, в мире Java разработки существует несколько простых правил, позволяющих практически полностью исключить
    возможности внедрения SQL:
</p>
<ol><li>
        Не использовать конкатенацию строк в запросах к базам данных.
    </li>
    <li>
        Использовать PreparedStatement/CallableStatement вместо Statement.
        Библиотеки spring-jdbc, Hibernate, MyBatis, JOOQ и прочие также внутри используют PreparedStatement.
    </li>
    <li>
        Передавать параметры запросов с помощью методов setParameter, а не в самом запросе. (Автоматически следует из первых двух правил.)
    </li>
</ol>
<p>
    Первое правило может быть ослаблено, чтобы запрет конкатенации касался только параметров запроса, но
    ради выразительности и читаемости кода я предпочитаю его в таком виде.
</p>
<p>
    Существуют и другие причины всегда писать программы следуя этим требованиям: корректность передачи параметров различных типов,
    производительность, краткость и выразительность кода.
    Поэтому кажется, что большинство разработчиков уже следует этим правилам и риск подверженности SQL-инъекциям в Java приложениях преувеличен.
    К сожалению, контрпримеры существуют, и поэтому сохраняется необходимость в повышенном внимании к данной проблеме.
    Например, на первой же странице поиска по Github c запросом "createStatement( ' language:java" мне удалось найти код в серьёзном проекте, потенциально подверженный внедрению SQL:

    <a href="https://github.com/stanfordnlp/CoreNLP/blob/3499d27e615c35702f23948e886a7389b5695c33/src/edu/stanford/nlp/util/GoogleNGramsSQLBacked.java#L101">github.com/stanfordnlp/CoreNLP... </a>
    {% highlight java %}
    if(str.contains("'")){
       str = StringUtils.escapeString(str, new char[]{'\''},'\'');
    }
    ...
    String phrase = escapeString(str);
    query = "select count from " + table + " where phrase='" + phrase+"';";{% endhighlight %}
    Возможно, автор предпринял усилия для защиты кода с помощью экранирования, но выбранный метод не является рекомендованным и надежным.
    Подробнее позже, иначе вступление будет слишком громоздким.
</p>
<p>
    Я хочу провести несколько экспериментов, чтобы выяснить, насколько просто получится воспроизвести уязвимость и устранить её,
    насколько критичен возможный ущерб на практике, а также как обнаружить незащищенный код. Подопытной базой данных будет PostgreSQL,
    а в качестве клиента - Spring Jdbc (JdbcTemplate) и JPA (Hibernate).
</p>

<h4>Тестовый проект</h4>
<p>
    Изучение уязвимости я буду проводить исключительно на слое работы с базой данных, то есть в рамках реализации DAO (Data Access Object) классов.
    В контексте веб-приложений контроллер или сервисный класс также может содержать логику проверки параметров (validate, sanitize),
    что безусловно снижает риск различных ошибок, в том числе косвенно и сценариев внедрения SQL.
    Это хорошая практика, но реализация DAO должна быть сама по себе устойчива к атакам.
</p>

<p>
    Для начала рассмотрю самый простой и классический сценарий: поиск на равенство по строковому полю.
    Для иллюстрации принципов возникновения SQL-инъекций и защиты от них этого будет достаточно.
</p>
    {% highlight sql %}
    CREATE TABLE BOOK (
        ID BIGSERIAL PRIMARY KEY,
        TITLE TEXT NOT NULL,
        CONSTRAINT name_length CHECK (length(TITLE) <= 512));  {% endhighlight %}
<p>
    Предположительно, в приложении существует необходимость искать книгу по точному совпадению названия,
    которое пользователь вводит на сайте в текстовом поле. На уровне DAO это означает выполнение такого кода:
</p>
    {% highlight java %}
    public List<BookEntity> findByTitle(String title) {
        String query = "select * from book where title = '" + title + "'";
        return jdbcTemplate.query(query, BOOK_ROW_MAPPER);
    } {% endhighlight %}
<p>
    При использовании конкатенации строк в реализации возможно в названии книги указать символ одинарной кавычки, а далее прервать запрос,
    изменить условие поиска, выполнить произвольный запрос. Нужно лишь, чтобы результирующий SQL скрипт был синтаксически корректен, что
    достигается просто и элегантно: title =
</p>
    {% highlight plaintext %}
    ' or '1'='1
    ';truncate book;
    ';truncate book; select '1    {% endhighlight %}
<p>
    Первое значение позволяет заменить условие поиска на безусловно верное, то есть получить всё содержимое таблицы.
    Второе приводит к неверному синтаксису запроса, потому что кавычка не закрыта, в результате чего он не выполняется. Но если его немного поправить, как в третьем случае,
    то очищается содержимое таблицы book. Это самый опасный вариант, в котором можно писать произвольные запросы, ограниченные лишь фантазией взломщика
    и правами пользователя базы данных.
</p>
<p>
    В тестовом проекте попытка выполнить метод с параметром title = "';truncate book; select '1" изначально была успешна и,
    несмотря на исключение ниже, таблица очищалась. Исключение выбрасывается уже после успешного выполнения скрипта потому
    что JdbcTemplate ожидает только один результат, а на самом деле их несколько, ведь мы превратили один запрос в три.
</p>
    {% highlight java %}
    org.springframework.dao.DataIntegrityViolationException:
        StatementCallback; SQL [select * from book where title = '';truncate book; select '1'];
        Multiple ResultSets were returned by the query.
    {% endhighlight %}
<p>
<p>
    После добавления аннотации @Transactional в классе JdbcBookRepositoryImpl очищение таблицы больше не происходит.
    Поведение программы при атаке стало таким:
</p>
<ol>
    <li>Атака изменяет запрос на такой: select * from book where title = '';truncate book; select '1'</li>
    <li>Запрос успешно выполняется</li>
    <li>При обработке результатов выполнения запроса выбрасывается исключение</li>
    <li>Транзакция откатывается</li>
</ol>
<p>
    Можно сказать, что благодаря правильному использованию JdbcTemplate и Spring, вред от атаки удалось существенно уменьшить.
</p>
<p>
    Реализация с использованием JPA при включении параметров в запрос с помощью конкатенации строк также подвержена внедрению SQL:
</p>
    {% highlight java %}
    @Override
    public List<BookEntity> findByTitle(String title) {
        String jpqlQuery = "select b from BookEntity b where b.title = '" + title + "'";
        var query = em.createQuery(jpqlQuery, BookEntity.class);
        return query.getResultList();
    }{% endhighlight %}

<p>
    Хотя в этом случае атака сложнее: нужно действовать в рамках синтаксиса JPQL запросов, желательно знать имена классов и свойств.
    Синтаксис более строгий и менее функциональный.
    Из вышеперечисленных атак удаётся только изменение условия на полную выборку (title = "' or '1'='1").
    Попытка завершить запрос и выполнить другой приводит к исключению:
</p>
    {% highlight java %}
    title = "';delete from BookEntity where '1'='1"

    org.springframework.dao.InvalidDataAccessApiUsageException: org.hibernate.query.SyntaxException:
      At 1:45 and token ';', mismatched input ';'...
    {% endhighlight %}

<h4>
    Экранирование
</h4>
<p>
    Справедливо отметить, что реализации, рассмотренные ранее, не только уязвимы к внедрению SQL, но и вообще не полностью корректны.
    Поиск книг, содержащих апостроф (например, O'Reilly), приводит к некорректному синтаксису запроса. Это общая проблема представления текстовой информации:
    в URL, Html, CSS, Json, yaml и т.д. существуют служебные символы, которые необходимо экранировать. В Java чтобы включить в строковую константу символ двойной кавычки
    нужно использовать символ обратного слэша ("\""). В html чтобы отобразить символы '<' или '>' используются конструкции &amp;lt; и &amp;gt;.
    Иными словами, задача экранирования служебных символов встречается повсеместно. Решение исключительно прямолинейно: изучить формат представления текста,
    идентифицировать логику экранирования и... использовать библиотеку, в которой всё уже реализовано.
    Например, для html подойдут apache-commons, guava, HtmlUtils в Spring, OWASP encoder.
    Для экранирования одинарной кавычки в SQL запросе в соответствии со стандартом нужно её удвоить ('').
    В некоторых СУБД также используется обратный слэш (\').
</p>
    {% highlight java %}
    @Override
    public List<BookEntity> findByTitle(String title) {
        String query = "select * from book where title = '" + escapeQuotes(title) + "'";
        return jdbcTemplate.query(query, BOOK_ROW_MAPPER);
    }

    static String escapeQuotes(String value) {
        return (value != null) ? value.replace("'", "''") : null;
    }  {% endhighlight %}
<p>
    Такая реализация корректно обрабатывает поиск книг с апострофом в названии и не подвержена SQL-инъекциям, по крайней мере тем,
    которые я пробовал ранее. Существует ли способ сломать такую защиту? Возможно. Точного ответа на этот вопрос найти не удалось, но многие сходятся в выводе,
    что такой метод защиты ненадежен и не рекомендован. В одной старой презентации на сайте OWASP описывается как можно обойти экранирование
    апострофа: <a href="https://owasp.org/www-pdf-archive/OWASP_IL_2007_SQL_Smuggling.pdf">https://owasp.org/www-pdf-archive/OWASP_IL_2007_SQL_Smuggling.pdf</a>.
    Для этого используется символ апострофа в какой-то нестандартной локали, который может быть преобразован автоматически в нормальный на стороне базы данных,
    минуя проверку в коде программы: (U+02BC -> U+0027).
    Разобраться в деталях безумно интересно, но слишком уводит в сторону от основной темы.
</p>
<p>
    Можно ли реализовать тот же приём, но с использованием проверенной надёжной библиотеки, учитывающей все служебные символы и отличия разных СУБД?
    Судя по всему, нет. Существует библиотека OWASP Esapi, которая, кроме прочего, призвана решить эту задачу и даже иногда применяется на практике:
</p>
    {% highlight java %}
    static String escapeSpecialCharacters(String value) {
        //available codecs: MySQL, DB2, Oracle. But there is no PostgreSQL codec!
        return ESAPI.encoder().encodeForSQL(new OracleCodec(), value);
    } {% endhighlight %}
<p>
    Кодека для PostgreSQL нет, но реализация OracleCodec выполняет в точности то же, что функция escapeQuotes выше.
    Поэтому код работает, хотя выглядит очень странно - база данных ведь не Oracle, а PostgreSQL!
</p>
<p>
    Причина, по которой я рассмотрел экранирование как возможное решение в том, что такой подход можно встретить.
    Например, в старом унаследованном коде. Предполагаю, что когда-то
    во многих проектах массово использовалась конкатенация строк для включения параметров в запросы.
    Потом в какой-то момент приходилось так же массово добавлять экранирование, потому что требовалось внести правки
    быстро и с минимальными изменениями, а переписывать код на использование параметризованных
    запросов намного более затратное и рискованное мероприятие. Не буду дальше углубляться в эту тему и перейду
    к правильному и общепринятому решению - параметризованным запросам.
</p>
<h4>
    Параметризованные запросы
</h4>
<p>
    Параметризованные запросы - концепция, которая противопоставляется динамически генерируемым запросам.
    Для вторых каждый раз, когда нужно выполнить поиск, система выполняет все шаги: формирование запроса конкатенацией,
    доставка запроса до базы данных средствами JDBC драйвера. На стороне БД: синтаксический разбор запроса, применение правил (rewrite system),
    оптимизация и выбор плана выполнения, выполнение.
</p>
<p>
    Для параметризованных запросов на всех уровнях реализовано разделение статического запроса и его динамических параметров:
</p>
<ol>
    <li>В Java коде: connection.prepareStatement(..) отделено от pstmt.setParameter(...) </li>
    <li>Драйвер базы данных передает параметры отдельно от запроса</li>
    <li>База данных выделяет параметры из запроса и кэширует план выполнения без учета параметров</li>
</ol>
<p>
    Используя такой подход, мы как разработчики, полагаемся на корректность реализации классов и библиотек Java, JDBC драйвера и самой СУБД.
    В контексте SQL-инъекций для работы такого понимания достаточно, но, безусловно, за внешней простотой скрывается большое количество тонкостей и нюансов.
    Например, в PostgreSQL существуют серверные параметризованные запросы, требующие пары запросов PREPARE - EXECUTE.
    Драйвер выбирает, сколько запросов кэшировать и в какой момент переходить с клиентского на серверный варианты.
    По умолчанию, четыре запроса будут клиентскими, а последующие - серверными. Изменть данное поведение можно вызовом метода pgStatement.setPrepareThreshold(...);
    Подробнее можно почитать здесь <a href="https://dev.to/yugabyte/postgres-query-execution-jdbc-prepared-statements-51e2">
    https://dev.to/yugabyte/postgres-query-execution-jdbc-prepared-statements-51e2</a>
</p>

<p>
    Далее приведу несколько реализаций с использованием параметризованных запросов. Все они корректны и не подвержены внедрению SQL.
    Работу непосредственно с Connection и PreparedStatement без использования вспомогательных библиотек я пропускаю - такой код слишком многословен,
    требует большого внимания к корректному управлению ресурсами (ResultSet, Statement и Connection), поэтому подвержен ошибкам.
</p>
    {% highlight java %}
    public List<BookEntity> findByTitle(String title) {
        String query = "select * from book where title = ?";
        return jdbcTemplate.query(query, ps -> ps.setString(1, title),
        BOOK_ROW_MAPPER);
    }  {% endhighlight %}

    {% highlight java %}
    @Entity
    @Table(name = "BOOK")
    @NamedQueries({
         @NamedQuery(name = "BookEntity.findById",
            query="select b from BookEntity b where b.title = :title")
    })
    public class BookEntity {
    ...
    @Override
    public List<BookEntity> findByTitle(String title) {
        var query = em.createNamedQuery("BookEntity.findById", BookEntity.class);
        query.setParameter("title", title);
        return query.getResultList();
    } {% endhighlight %}
    {% highlight java %}
    public interface SpringDataBookRepository extends JpaRepository<BookEntity, Long> {
        List<BookEntity> findByTitle(String title);

        @Query("select b from BookEntity b where b.title = :title")
        List<BookEntity> findByTitleExplicitJpql(String title);
    }{% endhighlight %}


<p>
    Перечисленные отрывки кода используют: JdbcTemplate, JPA EntityManager + NamedQuery, String Data (именованные методы, явный JPQL запрос).
    Синтаксис отличается, но во всех случаях присутствует общая семантика: параметр title отделён от запроса.
    Существует ещё множество способов доступа к данным в Java, можно использовать любой наиболее подходящий конкретному приложению.
    Снова возникает резонный вопрос - почему столько внимания уделяется SQL-инъекциям,
    если лучшее решение - просто применение современных подходов к работе с данными?
</p>

<h4>А есть ли проблема?</h4>
<p>
    Согласно  <a href="https://www.statista.com/statistics/806081/worldwide-application-vulnerability-taxonomy/#:~:text=SQL%20Injection%20is%20the%20main,site%20scripting%20(stored)%20attacks.">сайту www.statista.com</a>,
    23% всех критических уязвимостей в 2023 года относится к SQL-инъекциям, удерживающим лидерство в таблице.
    По другому отчёту 29% всех приложений всё ещё уязвимы к подобным атакам (Imperva Web Application Attack Report, WAAR, February 2020).
    Причин может быть много: легаси код, устаревшие образцы кода в сети, экономия.
    Возможно, что среди приложений на Java статистика выглядит лучше среднего, а на PHP - хуже.
</p>

                            <!--TODO : remove-->        </BookEntity></BookEntity></BookEntity></BookEntity></BookEntity></BookEntity></BookEntity>

<h3>Заключение</h3>
<p>

</p>

<p><a href="https://github.com/hipravin/samples-sql-injection">Код примеров на Github</a>.</p>


<h4>
    TODO: как сло

    https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html
    https://stackoverflow.com/questions/59855519/cannot-mitigate-sql-injections-using-owasp-esapi-veracode

    Detection of Injection Flaws in Java, C#, PHP, Python, JavaScript, TypeScript starts in SonarQube’s Developer Edition.
</h4>