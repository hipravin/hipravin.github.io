---
layout: post
title: Пишем код - Шахматы
excerpt: Простые браузерные шахматы на стеке Html+Jquery, Spring Boot
---

<p><a href="https://github.com/hipravin/samples-chess">Код на Github</a>.</p>

<p>
    Предыстория: когда-то давно я реализовывал шахматы в рамках лабораторной работы в университете.
    Целью была практика работы с сетевымм взаимодействиями через сокеты Unix, а также изучение ООП, так как реализация была на C++.
    Играли через терминал shell, а вместо фигур были буквы. Но все правила были реализованы строго.
    Сейчас я хочу повторить то же, но уже на Java. Постараюсь соблюдать процесс, которому бы я следовал, если бы это был не искусственный пример,
    а более-менее полноценная коммерческая разработка.
</p>

<p>
    Пост будет длинным и довольно подробным, но весь объём кода в него не поместится, поэтому предлагаю сразу скачать проект с github и открыть его в IDE.
    Здесь же буду приводить наиболее важные и показательные отрывки кода, основной уклон делая на ход рассуждений и принципы принятия решений.
</p>

<h4>
    Уточнение требований. Общий дизайн приложения.
</h4>

<p>
    В начале команда собирается вместе в уютной аудитории с белой доской и маркерами. Созывать видео конференцию хуже, а простой телефонный разговор - это уж совсем скучно и неэффективно.
    Нужно познакомиться с задачей, обсудить и уточнить требования, прикинуть сроки и возможные риски. В общем, нам требуются простенькие шахматы, работающие в браузере, без регистрации и аутентификации.
    Таймер решили пока не делать, сложные правила вроде ничьи по требованию игрока при повторении игровой ситуации более двух раз тоже пока не нужны. Интерфейс должен работать быстро,
    никаких пауз по полсекунды после хода игрока не должно быть. Сценарий начала игры один - тот, кто играет белыми заходит на главную страницу, копирует ссылку и отправляет второму игроку.
    Когда второй игрок переходит по полученной ссылке, начинается игра. Интерфейс не должен быть совсем деревянным, нужно подсвечивать возможные ходы фигур и не допускать невозможных.
    Также требуется защита от простейшего взлома - нельзя походить за соперника, влезть в чужую игру или снять фигуру с доски, когда соперник отвернется.
</p>

<p>
    Таковы в общих чертах бизнес требования. Если все согласны, то аналитики, команда тестирования и менеджер могут быть свободны или остаться, если им интересно,
    а разговор переходит к технической части. Вебсокеты! Html5 Unreal Engine! Kotlin! Kafka! Kubernetes! Смелые и осторожные, рациональные и безумные, традиционные и новаторские - всевозможные идеи,
    словно лозунги, доносились из разных сторон комнаты. Верите? Конечно, нет. Делаем на стандартном стеке, ничего лишнего, ничего нового. Слушали, постановили:
</p>

<ul>
    <li>Frontend - html + jquery</li>
    <li>Backend - Java 11, Spring Boot (web), Junit</li>
    <li>Никакой сессии или cookie. Закрыл вкладку в браузере - вышел из игры.</li>
    <li>Вебсокеты это слишком, привычный REST подойдет</li>
    <li>На стороне клиента не будет никакой логики. Какой фигурой и на какое поле можно походить сообщает сервер.
        При этом не должно быть пауз и подгрузок при выборе фигуры. </li>
    <li>У каждого игрока будет свой персональный токен, который будет передаваться с сервера при начале игры.
        Этот токен будет необходим при каждом ходе и будет передаваться в заголовке запроса.</li>
    <li>Работу над сервером и клиентом начинаем одновременно</li>
</ul>



<h4>
    Сервер (Back-end)
</h4>

<p>
    Задача хоть и понятная, но достаточно объёмная. Ясно, что правила так или иначе мы реализуем. Конь ходит буквой Гэ, если при этом не выйдет за границы доски. И на этом поле нет другой фигуры того же цвета.
    И если после хода не открывается король. Рокировка возможна, если ни одно из полей, которые пересекает король, не находится под боем и если король и ладья в этой партии ещё не ходили.
    Взятие на проходе возможно только на следующий ход, после этого право теряется. Когда пешка достигает последней линии, она повышается до одной из четырёх фигур.
    Короче говоря, работа кропотливая и количество условий и проверок огромно. Наша цель - написать код с минимальным количеством ошибок, хорошей читаемостью и структурой.
</p>

<p>
    Вторая важная часть - жизненный цикл игры. Где хранить состояние, как обрабатывать начало игры, ожидание хода соперника, параллельные игровые сессии?
    Архитектор сказал, что нужно использовать какой-то "Long polling".
    Пожалуй, придётся и с многопоточностью поработать.
</p>

<p>
    А что с самим интерфейсом, то есть с форматом данных? Фигуры, цвета, ходы... Фронтенд команда просит побыстрее предоставить первую версию сервиса,
    чтобы им было с чем работать и не сооружать моки (mocks).
    С этого тогда и начнём, а в процессе глубже вникнем в задачу и наметим план дальнейших действий.
</p>

<p>
    Попробуем спроектировать сервис, предоставляющий данные о состоянии партии.
    Понятно, что информация, которую мы должны передавать включает в себя положение всех фигур на доске.
    Также важно, на какое поле можно переместить каждую фигуру на своём ходу, ведь мы решили,
    что клиент будет "тонким", то есть без логики. Нужно указать, чей сейчас ход, последний ход соперника.
    Важно, продолжается ли партия и объявлен ли шах.
</p>

<p>
    Кроме того, какие данные мы включаем в ответ, важен также и формат.
    Плохой формат необоснованно увеличит размер сообщения и усложнит разработку клиентской части.
    Также может снизиться эффективность, но для доски размером 8*8 это несущественно, поэтому сделаем акцент на удобстве использования и понятности нашего сервиса.
</p>

<p>
    Все классы, являющиеся телом ответа (@ResponseBody, эта аннотация включена в @RestController), я собрал в отдельном пакете api.model и добавил к их именам постфикс "Dto".
    Я пользуюсь следующей конвенцией имён - бизнес сущности не имеют никакой специфики. К классам JPA добавляется окончание "Entity", а для REST интерфейса - Dto.
    Преобразовывать классы разных уровней приходится вручную.
    На одном из проектов, с которым я работал, все три случая обрабатывались одним классом и мне это показалось очень неудобным и хрупким подходом.
    В таком классе по умолчанию случайный геттер сразу попадает в JSON, а любое поле Hibernate пытается записать а базу. Когда с этим неизбежно возникает проблема,
    приходится расставлять повсюду всевозможные @JsonIgnore, transient и так далее. Кроме того, аннотации разных библиотек смешиваются вместе, а любые изменения нужно проверять на всех уровнях.
</p>

<p>
    Но вернёмся к шахматам. Я решил передавать только фигуры, присутствующие на доске. Пустые поля клиент должен определить сам методом исключения.
    Каждый раз передаётся полное состояние, а не только разница с предыдущим ходом. Позиции фигур будут строкой из двух символов ("e2", "f1")
    - это не очень удобно в коде сервера, зато очень кратко, естественно и понятно всем. Забегая вперед, скажу, что в самом движке позиция будет представлена классом из двух целых чисел от 1 до 8.
    Для типов фигур и цвета лучше всего подойдут перечисления (Enum), рассчитываем, что jackson по умолчанию успешно осуществит сериализацию и десериализацию enum в строку.
    (Для сравнения - JPA по умолчанию превращает enum в число и нужно указывать аннотацию @Enumerated(EnumType.STRING).
</p>

<p>
    Пока что создадим один сервис, с информацией о состоянии игры до первого хода. Вот, что получилось у меня. Это уже финальный результат,
    но я действительно начал с этого сервиса и изменения в формате данных минимальны.
    Из существенного - в первой версии я смоделировал позицию отдельной сущностью, но потом заменил
    на просто строку, чтобы Javascript код, работающий с этими данными был проще.
</p>

<p>
    GameStateDto - корневой класс. В нём список всех фигур, цвет текущего игрока, последний ход оппонента.
    Потом были добавлены ещё несколько вспомогательных полей для обработки окончания партии, но сейчас они не важны.

    {% highlight java %}
    public class GameStateDto {
        private List<PieceDto> pieces;
        private ColorDto currentPlayer;
        private MoveDto lastOpponentMove;
        ...
    }
    {% endhighlight %}
    PieceDto - одна фигура. Тип, цвет и поле. Интересно, что среди картинок фигур был вариант где один конь смотрит вправо, а другой - влево.
    В этом случае пришлось бы отличать одного от другого и хранит идентификатор. Но я решил, что для шахмат этого противоестественно, ведь теоретически в партии можно сделать до 10 коней для каждого игрока.

    {% highlight java %}
    public class PieceDto {
        private String position;
        private ColorDto color;
        private PieceTypeDto pieceType;

        private List<String> validMoves;
        ...
    }
    {% endhighlight %}
    Свойство validMoves - куда можно переместить фигуру. Этот список будет заведомо пуст или null в определённых случаях.
    Введение такой информации усложняет сервер, но иначе процесс хода выглядел бы так - игрок перемещает фигуру, а сервер подтверждает или отвечает ему - "Можно" или "Нельзя!".
    Конечно, всё это происходило бы с паузами не меньше 50-200ms на обработку запроса.
    Сейчас же клиент принимает только разрешённые ходы. Естественно, сервер всё равно должен их проверить на случай манипуляций.
    С перечислениями всё просто:

    {% highlight java %}

    public enum ColorDto {
        BLACK, WHITE
    }

    public enum PieceTypeDto {
        BISHOP,
        KING,
        KNIGHT,
        PAWN,
        QUEEN,
        ROCK;
    } {% endhighlight %}
    Создаём объект с парой фигур, чтобы оценить результат сериализации в JSON:

    {% highlight json %}

        {
        "pieces": [
              {
                  "position": "e2",
                  "color": "WHITE",
                  "pieceType": "PAWN",
                      "validMoves": [
                          "e3",
                          "e4"
                      ]
              },
              {
                  "position": "f7",
                  "color": "BLACK",
                  "pieceType": "PAWN",
                  "validMoves": null
              }
        ],
        "currentPlayer": "WHITE",
        "lastOpponentMove": null
        }    {% endhighlight %}
</p>

<p>
    Думаю, что это разумный максимум того, что мы можем предоставить команде, занимающейся клиентом до завершения реализации сервера.
    Так что теперь приступим к реализации правил и сервисов управления жизненным циклом игры (создание игры, подключение, ход, ожидание хода игрока, завершение партии).
    Игровой "движок", отвечающий за проверку всех правил игры - более сложная и объёмная составляющая, поэтому начну с него.
</p>

<h4>Game engine</h4>

<p>
    Реализация правил игры состоит из базовых типов и управляющих конструкций языка. Здесь нет взаимодействия с базой данных, веб-сервисов, многопоточности, масштабируемости,
    контейнеров и фреймворков. Только несколько классов и функций с проверками, циклами, конструкциями switch. Кроме того, алгоритмы очень простые, не требующие оптимальности ввиду маленького игрового поля,
    а также не использующие никаких сложных структур данных.
    Код, который нам нужно написать должен проверять, что слон ходит по диагонали и не перепрыгивает через другие фигуру того же цвета. Ладья - по вертикали и горизонтали.
    Пешка - на одно или два поля вперёд, а атакует по диагонали. Не забываем про рокировки и взятие на проходе (en passant).
    В общем, много отдельных случаев, каждый из которых прост, но сложно заставить всё работать правильно сразу. Хочется минимизировать риск ошибок, таких как:
    для белых проверяем, а для чёрных забыли; правую границу проверяем, а левую нет; пешка ходит не в ту сторону. В общем, всех ошибок, которые возможны когда в длинной цепочке
    проверок и сравнений нескольких чисел потеряли одну, перепутали меньше-больше или плюс с минусом.
</p>

<p>
    Давайте посмотрим на вот такой код. Что он делает, работает ли он? Сколько времени потребуется, чтобы разобраться с ним тому, кто его не писал?
    {% highlight java %}
    private List<Position> tricky(int x1, int y1) {
        List<Position> result = new LinkedList<>();

        for (int x2 = 1; x2 <= 8 ; x2++) {
            for (int y2 = 1; y2 <= 8; y2++) {
                int mx = Math.abs(x1 - x2);
                int my = Math.abs(y1 - y2);
                if( (mx + my == 3) && (mx * my == 2)
                    && Math.abs(x2 - 4.5) < 4.5
                    && Math.abs(y2 - 4.5) < 4.5) {
                        result.add(Position.of(x2,y2));
                }
            }
        }

        return result;
    }
    {% endhighlight %}
    Результат выполнения функции - все позиции, на которые можно переместить коня с поля (x1, y1). Кратко. Хитро. Не сразу придумаешь, особенно этот трюк с числом 4.5.
    Его корректность можно показать следующими рассуждениями:
    {% highlight plaintext %}
           x - в границе поля.
           1 <= x <= 8, x - целое число, следовательно
           0 < x < 9, следовательно,
        -4.5 < x - 4.5 < 4.5, то есть
           | x - 4.5 | < 4.5
    {% endhighlight %}
    В дополнение к коду придётся прикладывать математические выкладки.
        Однако этот код очень эффективный, и если убрать перебор всех клеток поля, что не очень сложно, то вероятно, будет оптимальным.
    Но нужна ли нам тиакая эффективность и оптимальность здесь? Думаю, что нет. Нам нужно, чтобы код был выразительным, понятным, поддерживаемым.
     Подробнее в посте про <a href="/2020-03-13-algorithm-complexity/">алгоритмическую сложность</a>.
</p>

<p>
    Я постарался в своей реализации минимизировать операции с целыми числами и проверки границ поля. Вся логика приложения "раскручивается" от четырёх операций с объектом класса Position:
    up1, down1, left1, right1. Up1 - значит на одно поле вверх. Понятие "вверх" одинаково для игрока за черных и за белых.

    {% highlight java %}
    public class Position {
        //from 1 to 8
        private final int x;
        private final int y;
        ...

        public Position up1() {
            return (y < 8) ? of(x, y + 1) : null;
        }
        public Position down1() {
            return (y > 1) ? of(x, y - 1) : null;
        }
        ...//right1, left1 - аналогично
    {% endhighlight %}
    Вместо null было бы неплохо использовать Optional, но тогда половина кода превращается в манипуляции с ним,
    поэтому я оставил null для случаев, когда при перемещении мы выходим за границы поля.
    Но за пределы класса Position значение null на практике не выходит. Также отмечу, что класс Position используется как неизменяемый (immutable) объект.
    Любой сдвиг - создание нового экземпляра объекта. Теперь напишем функцию up(), возвращающую все поля выше текущего до границы поля.
    {% highlight java %}
    public Stream<Position> up() {
        return Stream.iterate(this, Objects::nonNull, Position::up1).skip(1);
    }
    {% endhighlight %}
    Создаём stream при помощи итерации от текущего поля до null, на каждом шаге применяем функцию up1. Первый элемент, являющийся текущей позицией, пропускаем.
</p>

<p>
    Чтобы описать поведение коня, понадобится вспомогательная функция, применяющая несколько одинарных изменений позиции.
    Приходится использовать цикл вместо стрима, потому что результат move может быть равен null, а Stream (реализация ReferencePipeline) этого не допускает.
    По сути применяем move.apply(finalPosition) пока не закончатся элементы в массиве moves или операция не вернёт null.
    {% highlight java %}
    private Position move(UnaryOperator<Position>... moves) {
        Position finalPosition = this;
        for (int i = 0; i < moves.length && (finalPosition != null); i++) {
            UnaryOperator<Position> move = moves[i];
            finalPosition = move.apply(finalPosition);
        }
        return finalPosition;
    }
    {% endhighlight %}
    И вот, что в результате получается для коня:
    {% highlight java %}
    public List<Position> knight() {
        List<Position> moves = new LinkedList<>();
        moves.add(move(Position::up1, Position::up1, Position::right1));
        moves.add(move(Position::up1, Position::up1, Position::left1));
        moves.add(move(Position::down1, Position::down1, Position::right1));
        moves.add(move(Position::down1, Position::down1, Position::left1));
        moves.add(move(Position::right1, Position::right1, Position::up1));
        moves.add(move(Position::right1, Position::right1, Position::down1));
        moves.add(move(Position::left1, Position::left1, Position::up1));
        moves.add(move(Position::left1, Position::left1, Position::down1));

        moves.removeIf(Objects::isNull);
        return moves;
    }
    {% endhighlight %}
    Можно подумать, как избавиться от восьми однотипных строчек, применив какой-нибудь перебор, но ради одной функции это неразумно.
    По ходу дела проверяем всё юнит тестами, потому что опечатки и ошибки по невнимательности здесь вполне вероятны.
    {% highlight java %}
    @Test
    void testKnight1() {
        Position p = Position.of(1, 1);
        List<Position> kn = p.knight();
        assertEquals(2, kn.size());
        assertTrue(kn.contains(Position.of(3, 2)));
        assertTrue(kn.contains(Position.of(2, 3)));
    }

    @Test
    void testKnight2() {
        Position p = Position.of(4, 3);
        Set<Position> kn = new HashSet<>(p.knight());
        assertEquals(8, kn.size());
    }
    {% endhighlight %}
    Я проверяю угловое поле и центральное, поверхностно. Планирую, что тесты на более высокоуровневую логику заодно проверят и эту.
</p>

<p>
    Подобным образом в классе Position реализованы все перемещения фигур, которые не зависят от других фигур на доске или хода партии.
    Сейчас мы работаем над тем, чтобы для каждой фигуры определить поля, на которые активный игрок вправе её переместить. Для продолжения нужно
    научиться хранить все фигуры. За это отвечает класс Board.
    {% highlight java %}
    public class Board implements Cloneable {
        final Map<Position, Piece> whitePieces = new HashMap<>();
        final Map<Position, Piece> blackPieces = new HashMap<>();
        ...
    }
    public class ChessGame {
        final PieceColor currentPlayer;
        final List<Board> previousStates;
        final List<PieceMove> previousMoves;
        final Board board;
        ...
    }

    public abstract class Piece {
        final Position position;
        final PieceColor pieceColor;
        final Type pieceType;
        ...
        public abstract Set<Position> validPieceMoves(ChessGame game);

        public final Set<Position> finallyValidMoves(ChessGame game) {
            Set<Position> moves = validPieceMoves(game);

            //remove target positions where same team pieces are present
            moves.removeIf(pos ->
            game.at(pos).map(piece -> piece.pieceColor == pieceColor).orElse(false));

            //remove target positions where king will be in trouble after move
            PieceColor currentPlayer = game.getCurrentPlayer();
            moves.removeIf(m -> game.applyMoveNoValidate(new PieceMove(position, m)).kingUnderAttack(currentPlayer));

            return moves;
         }
    }
    {% endhighlight %}
    Абстрактный класс Piece определяет свойства и поведение общее для всех фигур: нельзя перемещать фигуры на поля, занятые другими фирурами того же игрока,
    после хода король не может попасть или остаться под боем. При этом в общем случае требуется не только информация о текущем положении фигур (Board), но и информация о ходе партии, поэтому
    в качестве параметра используется ChessGame.
    Классы Pawn, King, Queen и другие наследуют Piece и отвечают за реализацию сильно специфичного поведения фигур, наподобие рокировок или ходов пешек.
</p>

<p>
    Код классов Queen, Bishop, King, Rock - однотипный и тривиальный:
    {% highlight java %}

    public class Queen extends Piece {
        ...
        @Override
        public Set<Position> validPieceMoves(ChessGame game) {
            return position.moveUntilHit(position.queen(), game, pieceColor);
        }
        ...
    }
    {% endhighlight %}
    А вот для пешки или короля приходится всё-таки использовать разветвлённые if-else конструкции, соответствующие всем проверкам.
    Ниже, например, реализована проверка возможности взятия на проходе. Напомню, что пешка одного цвета может атаковать пешку соперника, если на предыдущем ходе
    пешка соперника была перемещена на два поля вперед и таким образом пересекла поле, находящееся под боем.
    {% highlight java %}
    Map<PieceColor, UnaryOperator<Position>> MOVE_FOWARD = Map.of(
        PieceColor.WHITE, Position::up1,
        PieceColor.BLACK, Position::down1
    );

    private Optional<Position> enPassant(ChessGame game) {
        if (!ENPASSANT_LINE.get(pieceColor).equals(position.getY())
            || game.getPreviousMoves().isEmpty()) {
            return Optional.empty();
        }
        UnaryOperator<Position> moveForward = MOVE_FOWARD.get(pieceColor);
        UnaryOperator<Position> moveBackward = MOVE_BACKWARD.get(pieceColor);
        Position fl = moveForward.apply(position).left1();
        Position fr = moveForward.apply(position).right1();

        for (Position forwardAttack : new Position[]{fl, fr}) {
             if (forwardAttack != null) {
                  Position near = moveBackward.apply(forwardAttack);
                  Position nearFrom = moveForward.apply(forwardAttack);

                  PieceMove lastOppMove = game.getPreviousMoves().get(game.getPreviousMoves().size() - 1);
                  if (game.at(near).map(p -> p.getPieceType() == Type.PAWN && p.pieceColor != pieceColor).orElse(false)
                        && lastOppMove.getFrom().equals(nearFrom)
                        && lastOppMove.getTo().equals(near)) {
                      return Optional.of(forwardAttack);
                  }
             }
        }

        return Optional.empty();
    }
    {% endhighlight %}
    С таким кодом придётся разбираться в любом случае, потому что запутанная логика исходит из бизнес требований, а не из неудачного подхода или
    плохой реализации. Стараемся выделить подобный код в отдельную функцию и не смешивать с остальной частью, работающей по более-менее стандартной логике.
    Важно унифицировать логику для белых и чёрных, иначе все тесты придётся писать для обеих сторон. Тесты писать муторно и скучно, потому что приходится
    воссоздавать ситуацию на доске целиком, но этого не избежать. Во время реализации я проверил все сценарии в тестах, кроме повышения пешки до другой фигуры, которое я решил
    воспроизвести уже с помощью браузера. И конечно же, там была ошибка по типу copy-paste: ход применялся к исходному полю, а не к его копии (классы Board, ChessGame и другие
    хоть и имеют изменяемое внутреннее состояние, но перед манипуляциями создаются копии объектов).
</p>

<p>
    Так выглядит тест, проверяющий, что единственный ходя для белого коня - атаковать чёрного коня, чтобы снять шах с короля.
    В тестах много вспомогательных функций, чтобы сделать их более читаемыми.
    {% highlight java %}
    @Test
    void testValidMovesKnight1() {
         Piece whiteKing = new King(Position.of(2,2), PieceColor.WHITE);
         Piece blackKnight = new Knight(Position.of(4,3), PieceColor.BLACK);
         Piece whiteKnight = new Knight(Position.of(5,5), PieceColor.WHITE);

         Board board = new Board(Arrays.asList(whiteKing, whiteKnight, blackKnight));
         ChessGame chessGame = new ChessGame(PieceColor.WHITE, Collections.emptyList(), Collections.emptyList(), board);
         Set<Position> validMoves = whiteKnight.finallyValidMoves(chessGame);

         assertEquals(Sets.newSet(blackKnight.getPosition()), validMoves);
    }
    {% endhighlight %}
</p>

<p>
    Возможность для каждой фигуры определить список разрешённых ходов позволяет легко реализовать проверки окончания партии, шаха и мата.
    {% highlight java %}
    public boolean kingUnderAttack(PieceColor player) {
        Set<Position> attackPositions =
            board.pieces(player.negate()).stream()
                .flatMap(p -> p.validPieceMoves(this).stream())
                .collect(Collectors.toSet());

        return attackPositions.contains(board.king(player));
    }

    public void updateGameStatus() {
        this.validMovesForCurrentPlayer = validMovesForCurrentPlayer();

        boolean kingAttacked = kingUnderAttack(currentPlayer);
        boolean canMove = validMovesForCurrentPlayer.values().stream().anyMatch(s -> !s.isEmpty());

        if (canMove && kingAttacked) {
            status = GameStatus.CHECK;
        }
        if (!canMove && kingAttacked) {
            status = GameStatus.CHECKMATE;
            finished = true;
        }
        if (!canMove && !kingAttacked) {
            status = GameStatus.DRAW_STALEMATE;
            finished = true;
        }
    }
    {% endhighlight %}
</p>

<p>
    Я очень интенсивно использую Optional и Stream, поэтому полагаю, что код можем показаться сложнее, чем если бы
    те же проверки осуществлялись простыми циклами и проверками if-else. В первом случаем код получается более декларативным, то есть он
    описывает "что" нужно сделать, а второй - императивный, то есть "как" сделать, указав конкретные шаги.
    Декларативный подход чаще всего лучше, но к нему нужно привыкнуть.
</p>

<p>
    Когда поведение всех фигур, а также проверки окончания партии реализованы, можно написать тест, проверяющий всё в сборе.
    Например, убедимся, что детский мат - действительно приводит к победе в три хода:
    {% highlight java %}
    @Test
    void testMoves() {
        ChessGame game = ChessGame.startGame();
        List<PieceMove> moves = movesFromString("e2e4 e7e5 d1h5 b8c6 f1c4 g8f6 h5f7").collect(Collectors.toList());
        for (PieceMove move : moves) {
            game = game.applyMove(move);
        }

        assertTrue(game.isFinished());
        assertEquals(GameStatus.CHECKMATE, game.getStatus());
    }
    {% endhighlight %}
</p>

<p>
    Мы всё ещё не можем быть уверены, что ошибок нет, очень много игровых ситуаций не проверено ни вручную, ни автоматически, хотя с учётом ещё нескольких тестов, которые я не упомянул,
    покрытие строк кода почти полное. Но покрытие строк далеко от покрытия всех сценариев. Как же быть? Как правило, тестирование проводит отдельная команда, которая собирает
    и поддерживает достаточный список проверок приложения (все или основные бизнес сценарии). По возможности эти проверки автоматизируются, но это уже не юнит тесты, а проверки на живом окружении,
    в котором приложение работает в условиях, близких к продакшену. Давайте подумаем, как бы мы могли улучшить тесты, чтобы увеличить уверенность в том, что реализация работает верно.
    Идею написать больше однотипных тестов оставим без рассмотрения как очевидную.
    Один из вариантов - если бы существовала гарантированно правильная реализация, то мы могли бы сравнить поведение на большом количестве случайных партий.
    Это очень удачный случай, но не часто будет такая реализация, которую мы можем назвать эталонной, можем использовать в тесте, но не в коде.
    Другой вариант - если бы удалось получить архив реальных шахматных партий в текстовом формате - тогда можно проверить, что все ходы и результаты партий согласуются с нашей реализацией.
    Правда, так мы проверим только заведомо разрешённые ходы. Сейчас же в плане юнит тестов остановимся на достигнутом.
</p>




<h4>
    Фронтенд (Front-end)
</h4>

<p>
    Теперь приступим к реализации интерфейса. Как правило, во внутренних корпоративных системах фронтендом могут заниматься Java разработчики.
    В таких приложения от сайта не требуется работать во всех браузерах на всех устройствах, иметь красивые современные стили и анимации и так далее.
    В общем, интерфейс должен быть функциональным и рабочим, но конкурировать ни с кем не приходится. Если же нужен качественный, можно сказать, профессиональный сайт для широкой аудитории,
    то чаще его разрабатывает отдельная команда.
</p>

<p>
    Для наших шахмат попробуем реализовать простой функциональный интерфейс без изысков, но и не в стиле 90-x, по возможности.
    Тем не менее, вполне вероятно, что мы распределили задачи по разработке бэкенда и фронтенда между сотрудниками отдела.
    Поэтому будем исходить из предположения, что сервер ещё не готов, максимум существует REST интерфейс,
    который поддерживает несколько простых вызовов, чтобы мы могли сориентироваться по формату данных.
</p>

<p>
    Для начала создадим минимальный набор файлов: index.html, main.js, main.css, а также скопируем bootstrap и jquery. Пока что все файлы помещаем в корень директории static.
    Если файлы будут множиться, создам отдельные директории для Javascript или CSS файлов. Так же сразу в index.html добавляем минимальный head, пустой body м подключаем css и js.
</p>

<p>
    Теперь подумаем над задачей. Я думаю, что лучше сначала сконцентрироваться на "движке" - отображении шахматной доски и фигур, обработку общения с сервером и совершение ходов.
    Начало игры, поиск противников а также реализацию шахматных часов пока отложим. Эту часть работы можно выполнить максимально изолированно, пока остальные требования будут, возможно, уточняться.
    Также, по первому впечатлению, это самая технически сложная и объёмная часть.
</p>

<p>
    Как же отобразить шахматное поле? Можно воспользоваться canvas - будем рисовать все границы, линии и фигуры самостоятельно.
    Canvas позволит нарисовать всё, что угодно, но кажется слишком сложно, долго и муторно.
    Если можно сделать отображение на чистом html - это было бь лучше. Какие возможности интерфейса нам нужны?
</p>
<ol>
    <li>Доска - всегда 8*8, никак не трансформируется</li>
    <li>Ход - клик на одно поле, подсветка полей, на которые можно переместить фигуру м клик на второе поле</li>
    <li>Поле - квадрат фиксированного размера, чёрное или белое, может содержать одну из шести шахматных фигур</li>
</ol>

<p>
    Кажется, используя дивы или таблицы, вполне можно удовлетворить все требования.
    Давайте попробуем сформировать такую таблицу, пока что без фигур. Вспомним тех задание:
</p>
<p>
    <img class="code-snapshot" src="/img/posts/chess/board1.png"
         alt="картинки нет, но вы держитесь"/>
</p>

<p>
    Так, само поле 8*8, но ещё есть обозначения по краям - то есть заведём таблицу 10*10. Для начала из пары строк:
</p>



<p>
    {% highlight html %}

    <table class="table-bordered">
        <tr>
            <td></td><td>a</td><td>b</td><td>c</td><td>d</td><td>e</td><td>f</td><td>g</td><td>h</td><td></td>
        </tr>
        <tr>
            <td>8</td>
            <td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>8</td>
        </tr>
    </table>
    {% endhighlight %}
</p>
<div class="container">
   <div class="row">
       <table class="table-bordered">
           <tr>
               <td></td><td>a</td><td>b</td><td>c</td><td>d</td><td>e</td><td>f</td><td>g</td><td>h</td><td></td>
           </tr>
           <tr>
               <td>8</td>
               <td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>8</td>
           </tr>
       </table>
   </div>
</div>

<p>
    Вроде получается, но сразу понятно, что нам нужно контролировать размеры ячеек и отличать чёрные от белых.
    Поэтому проставим css классы cell, cell-white, cell-black в таблице и объявим их в main.css с минимальными настройками.
</p>

<p>
    {% highlight html %}
    <tr>
         <td>8</td>
         <td class="cell cell-black"></td>
         <td class="cell cell-white"></td>
    ...
    {% endhighlight %}
    {% highlight css %}
     .cell {
         width: 60px;
         height: 60px;
     }
     .cell-white {
         background-color: #ffff80;
     }
     .cell-black {
        background-color: #a3a264;
     }
   {% endhighlight %}
    Я выбрал цвета с оттенком желтого. Хочу, чтобы было похоже на старые советские деревянные лакированные шахматы.
    Результат:

</p>

<div class="container">
    <div class="row">
        <table class="table-bordered">
            <tr>
                <td></td>
                <td>a</td>
                <td>b</td>
                <td>c</td>
                <td>d</td>
                <td>e</td>
                <td>f</td>
                <td>g</td>
                <td>h</td>
                <td></td>
            </tr>
            <tr>
                <td>8</td>
                <td class="cell cell-black"></td>
                <td class="cell cell-white"></td>
                <td class="cell cell-black"></td>
                <td class="cell cell-white"></td>
                <td class="cell cell-black"></td>
                <td class="cell cell-white"></td>
                <td class="cell cell-black"></td>
                <td class="cell cell-white"></td>
                <td>8</td>
            </tr>
        </table>
    </div>
</div>

<p>
    Буквы не по центру, лишние границы по краям, в остальном движемся верно. Подобные мелочи оставлю за кадром.
    Давайте ещё добавим фигуры и подсветку полей, на которую можно перемещать фигуру и фигур под боем, а также выбранной фигуры.
    Изображения возьмём векторные и наличие фигуры на поле будет определяться css стилем или data атрибутами, а не содержимым ячейки таблицы.
    Так будет проще изменять состояние, потому что не нужно создавать или удалять html элементы.
    Я выбрал data атрибуты, по сути для подобных целей они идеально подходят.
</p>

<p>
    {% highlight html %}
    <td class="cell cell-black" data-piece="bishop-black"></td>
    <td class="cell cell-white" data-piece-state="move"></td>
    <td class="cell cell-black"></td>
    <td class="cell cell-white" data-piece-state="eat"></td>
    <td class="cell cell-black"></td>
    <td class="cell cell-white" data-piece-state="selected"></td>
    {% endhighlight %}

    {% highlight css %}
    td[data-piece='bishop-black']{
       background-image: url("/img/posts/chess/bishop.svg");
       background-size: contain;
    }

    td[data-piece-state='selected']{
       border: 5px solid black !important;
    }

    td[data-piece-state='eat']{
      border: 5px solid red !important;
    }

    td[data-piece-state='move']{
        border: 5px solid green !important;
    }
    {% endhighlight %}
</p>

<div class="container">
    <div class="row">
        <table class="table-bordered">
            <tr style="text-align: center">
                <td></td>
                <td>a</td>
                <td>b</td>
                <td>c</td>
                <td>d</td>
                <td>e</td>
                <td>f</td>
                <td>g</td>
                <td>h</td>
                <td></td>
            </tr>
            <tr>
                <td>8</td>
                <td class="cell cell-black" data-piece="bishop-black"></td>
                <td class="cell cell-white" data-piece-state="move"></td>
                <td class="cell cell-black"></td>
                <td class="cell cell-white" data-piece-state="eat"></td>
                <td class="cell cell-black"></td>
                <td class="cell cell-white" data-piece-state="selected"></td>
                <td class="cell cell-black"></td>
                <td class="cell cell-white"></td>
                <td>8</td>
            </tr>
        </table>
    </div>
</div>

<p>
    Выглядит неплохо. Не получается пока обойтись одной svg картинкой для каждой фигуры, вероятно придётся
    отдельно иметь bishop-black.svg и bishop-white.svg (fill:white почему-то не помогает). Опять же, не зацикливаемся на подобных мелочах.
</p>

<p>
    Таким образом мы определили основные необходимые html элементы и стили и можем заняться динамической манипуляцией этими данными в JS.
    Работу по улучшению визуальной компоненты можно оставить на потом или передать кому-то. Нужно учитывать ограничения времени и приоритеты задач.
    Неровные границы или плохо сочетающиеся цвета нам простят и преподаватель на зачёте и пользователи сервиса, если основной функционал будет работать на отлично, но не наоборот.
</p>

<p>

</p>



...
<p>
    Отмечу, что мне не очень нравится, как структурирован Javascript код: всё в одном файле, все функции и переменные глобальные. Нужные функции постоянно приходится искать поиском.
    Кроме того, нет ни единого юнит теста, поэтому при внесении изменений приходится вручную проверять основные сценарии.
    Для примера и демонстрации отдельных функций сгодится, но для серьезного приложения нужно изучать более продвинутые практики. Например, использовать прототипы
    и таким образом распределять код на разные классы. Возможно, следует писать на typescript, а не чистом javascript. Frontend разработчики успешно пользуются этими приемами.
    Однако в простых приложениях это выглядит избыточным.
</p>

...