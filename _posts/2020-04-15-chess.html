---
layout: post
title: Пишем код - Шахматы
excerpt: Простые браузерные шахматы на стеке Html+Jquery, Spring Boot
---

<p>
    Предыстория: когда-то давно я реализовывал шахматы в качестве лабораторной работы во время обучения.
    Тогда целью была практика работы с сетевымм взаимодействиями посредством сокетов Unix, а также изучение ООП, так как реализация была на C++.
    Играли через терминал shell, а вместо фигур были буквы. Но все правила и даже шахматный таймер были реализованы строго.
    Сейчас я хочу повторить то же, но уже на Java. Постараюсь соблюдать процесс, которому бы я следовал, если бы это был не пример для блога,
    а полноценная коммерческая разработка.

</p>

<h4>
    Сервер (Back-end)
</h4>







<p>
    ...
    Хочется, чтобы каждый класс и метод был настолько простым, прямолинейным и понятным, насколько это возможно.
    Вторая цель - попробовать реализовать правила сразу без ошибок. Достичь этого попробуем потратив больше времени на проработку дизайна движка.
    Также будем отдавать предпочтение простым конструкциям перед сложными но более оптимальными. Зато потом сэкономим время на поиске ошибок в бесконечных "ифах"
    (сложных многоуровневых проверках if - else).


</p>






<h4>
    Фронтенд (Front-end)
</h4>

<p>
    Теперь приступим к реализации интерфейса. Как правило, во внутренних корпоративных системах фронтендом могут заниматься Java разработчики.
    В таких приложения от сайта не требуется работать во всех браузерах на всех устройствах, иметь красивые современные стили и анимации и так далее.
    В общем, интерфейс должен быть функциональным и рабочим, но конкурировать ни с кем не приходится. Если же нужен качественный, можно сказать, профессиональный сайт для широкой аудитории,
    то чаще его разрабатывает отдельная команда.
</p>

<p>
    Для наших шахмат попробуем реализовать простой функциональный интерфейс без изысков, но и не в стиле 90-x, по возможности.
    Тем не менее, вполне вероятно, что мы распределили задачи по разработке бэкенда и фронтенда между сотрудниками отдела.
    Поэтому будем исходить из предположения, что сервер ещё не готов, максимум существует REST интерфейс,
    который поддерживает несколько простых вызовов, чтобы мы могли сориентироваться по формату данных.
</p>

<p>
    Для начала создадим минимальный набор файлов: index.html, main.js, main.css, а также скопируем bootstrap и jquery. Пока что все файлы помещаем в корень директории static.
    Если файлы будут множиться, создам отдельные директории для Javascript или CSS файлов. Так же сразу в index.html добавляем минимальный head, пустой body м подключаем css и js.
</p>

<p>
    Теперь подумаем над задачей. Я думаю, что лучше сначала сконцентрироваться на "движке" - отображении шахматной доски и фигур, обработку общения с сервером и совершение ходов.
    Начало игры, поиск противников а также реализацию шахматных часов пока отложим. Эту часть работы можно выполнить максимально изолированно, пока остальные требования будут, возможно, уточняться.
    Также, по первому впечатлению, это самая технически сложная и объёмная часть.
</p>

<p>
    Как же отобразить шахматное поле? Можно воспользоваться canvas - будем рисовать все границы, линии и фигуры самостоятельно.
    Canvas позволит нарисовать всё, что угодно, но кажется слишком сложно, долго и муторно.
    Если можно сделать отображение на чистом html - это было бь лучше. Какие возможности интерфейса нам нужны?
</p>
<ol>
    <li>Доска - всегда 8*8, никак не трансформируется</li>
    <li>Ход - клик на одно поле, подсветка полей, на которые можно переместить фигуру м клик на второе поле</li>
    <li>Поле - квадрат фиксированного размера, чёрное или белое, может содержать одну из шести шахматных фигур</li>
</ol>

<p>
    Кажется, используя дивы или таблицы, вполне можно удовлетворить все требования.
    Давайте попробуем сформировать такую таблицу, пока что без фигур. Вспомним тех задание:
</p>
<p>
    <img class="code-snapshot" src="/img/posts/chess/board1.png"
         alt="картинки нет, но вы держитесь"/>
</p>

<p>
    Так, само поле 8*8, но ещё есть обозначения по краям - то есть заведём таблицу 10*10. Для начала из пары строк:
</p>



<p>
    {% highlight html %}

    <table class="table-bordered">
        <tr>
            <td></td><td>a</td><td>b</td><td>c</td><td>d</td><td>e</td><td>f</td><td>g</td><td>h</td><td></td>
        </tr>
        <tr>
            <td>8</td>
            <td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>8</td>
        </tr>
    </table>
    {% endhighlight %}
</p>
<div class="container">
   <div class="row">
       <table class="table-bordered">
           <tr>
               <td></td><td>a</td><td>b</td><td>c</td><td>d</td><td>e</td><td>f</td><td>g</td><td>h</td><td></td>
           </tr>
           <tr>
               <td>8</td>
               <td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>8</td>
           </tr>
       </table>
   </div>
</div>

<p>
    Вроде получается, но сразу понятно, что нам нужно контролировать размеры ячеек и отличать чёрные от белых.
    Поэтому проставим css классы cell, cell-white, cell-black в таблице и объявим их в main.css с минимальными настройками.
</p>

<p>
    {% highlight html %}
    <tr>
         <td>8</td>
         <td class="cell cell-black"></td>
         <td class="cell cell-white"></td>
    ...
    {% endhighlight %}
    {% highlight css %}
     .cell {
         width: 60px;
         height: 60px;
     }
     .cell-white {
         background-color: #ffff80;
     }
     .cell-black {
        background-color: #a3a264;
     }
   {% endhighlight %}
    Я выбрал цвета с оттенком желтого. Хочу, чтобы было похоже на старые советские деревянные лакированные шахматы.
    Результат:

</p>

<div class="container">
    <div class="row">
        <table class="table-bordered">
            <tr>
                <td></td>
                <td>a</td>
                <td>b</td>
                <td>c</td>
                <td>d</td>
                <td>e</td>
                <td>f</td>
                <td>g</td>
                <td>h</td>
                <td></td>
            </tr>
            <tr>
                <td>8</td>
                <td class="cell cell-black"></td>
                <td class="cell cell-white"></td>
                <td class="cell cell-black"></td>
                <td class="cell cell-white"></td>
                <td class="cell cell-black"></td>
                <td class="cell cell-white"></td>
                <td class="cell cell-black"></td>
                <td class="cell cell-white"></td>
                <td>8</td>
            </tr>
        </table>
    </div>
</div>

<p>
    Буквы не по центру, лишние границы по краям, в остальном движемся верно. Подобные мелочи оставлю за кадром.
    Давайте ещё добавим фигуры и подсветку полей, на которую можно перемещать фигуру и фигур под боем, а также выбранной фигуры.
    Изображения возьмём векторные и наличие фигуры на поле будет определяться css стилем или data атрибутами, а не содержимым ячейки таблицы.
    Так будет проще изменять состояние, потому что не нужно создавать или удалять html элементы.
    Я выбрал data атрибуты, по сути для подобных целей они идеально подходят.
</p>

<p>
    {% highlight html %}
    <td class="cell cell-black" data-piece="bishop-black"></td>
    <td class="cell cell-white" data-piece-state="move"></td>
    <td class="cell cell-black"></td>
    <td class="cell cell-white" data-piece-state="eat"></td>
    <td class="cell cell-black"></td>
    <td class="cell cell-white" data-piece-state="selected"></td>
    {% endhighlight %}

    {% highlight css %}
    td[data-piece='bishop-black']{
       background-image: url("/img/posts/chess/bishop.svg");
       background-size: contain;
    }

    td[data-piece-state='selected']{
       border: 5px solid black !important; ;
    }

    td[data-piece-state='eat']{
      border: 5px solid red !important;
    }

    td[data-piece-state='move']{
        border: 5px solid green !important;
    }
    {% endhighlight %}
</p>

<div class="container">
    <div class="row">
        <table class="table-bordered">
            <tr style="text-align: center">
                <td></td>
                <td>a</td>
                <td>b</td>
                <td>c</td>
                <td>d</td>
                <td>e</td>
                <td>f</td>
                <td>g</td>
                <td>h</td>
                <td></td>
            </tr>
            <tr>
                <td>8</td>
                <td class="cell cell-black" data-piece="bishop-black"></td>
                <td class="cell cell-white" data-piece-state="move"></td>
                <td class="cell cell-black"></td>
                <td class="cell cell-white" data-piece-state="eat"></td>
                <td class="cell cell-black"></td>
                <td class="cell cell-white" data-piece-state="selected"></td>
                <td class="cell cell-black"></td>
                <td class="cell cell-white"></td>
                <td>8</td>
            </tr>
        </table>
    </div>
</div>

<p>
    Выглядит неплохо. Не получается пока обойтись одной svg картинкой для каждой фигуры, вероятно придётся
    отдельно иметь bishop-black.svg и bishop-white.svg (fill:white почему-то не помогает). Опять же, не зацикливаемся на подобных мелочах.
</p>

<p>
    Таким образом мы определили основные необходимые html элементы и стили и можем заняться динамической манипуляцией этими данными в JS.
    Работу по улучшению визуальной компоненты можно оставить на потом или передать кому-то. Нужно учитывать ограничения времени и приоритеты задач.
    Неровные границы или плохо сочетающиеся цвета нам простят и преподаватель на зачёте и пользователи сервиса, если основной функционал будет работать на отлично, но не наоборот.
</p>

<p>

</p>